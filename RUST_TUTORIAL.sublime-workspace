{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"ci",
				"icivixwalter"
			]
		]
	},
	"buffers":
	[
<<<<<<< HEAD
=======
		{
			"contents": "RUST_TUTORIAL_CARLO_MILANESI\n\tNote\n\t\tquesto è un tutorial in italiano di carlo milanensi e \n\t\tsi trova qui:\n\n\n\tCREARE_FILE_PROGETTO\n\t\trust è create per Tier o 3 livelli con diverse garanzie.\n\t\tLe piattaforme sono identificate con la target-triple = ossia la stringa che (terna-bersalio) che informa il compilatore su quale output deve essere prodotto.\n\n\t\tLIVELLO 1\n\t\t\tLe piattaforme di livello 1 possono essere pensate come \"con garanzia di compilazione e funzionamento\".\n\t\tLIVELLO 2\n\t\t\tLe piattaforme di livello 2 possono essere pensate come \"con compilazione garantita\". I collaudi automatizzati non vengono eseguiti, e quindi non è garantito che si producano eseguibili che funzionino, ma queste piattaforme spesso funzionano abbastanza bene e le migliorie sono sempre benvenute! \n\n\t\tLIVELLO 3\n\t\t\tLe piattaforme di livello 3 sono quelle per cui Rust ha supporto, ma per applicare delle modifiche non è necessario né eseguire la compilazione, né passare i testi di collaudo. Gli eseguibili funzionanti su tali piattaforme possono essere lacunosi, dato che la loro affidabilità è spesso definita in termini di contributi dalla comunità. In aggiunta, gli artefatti di rilascio e gli installatori non sono forniti, ma ci possono essere infrastrutture comunitarie che li producono in luoghi non ufficiali.\n\n\tINSTALLAZIONE\n\t\tsu linux, windows ecc..\n\n\tNUMERO_DI_VERSIONE\n\t\tAprire il terminale e controllare il numero di @versione di @rust:\n\t\t\trustc --version\n\n\t\tPer windows controllare la variabile di sistema con \n\t\t\techo %PATH%.\n\t\tse non esiste impostarla manualmente in quanto  gli eseguibili di Rust si trovano in una directory come \"C:\\Program Files\\Rust stable GNU 1.x\\bin\".\n\n\t\t... RUST non fa i link\n\n\tCREARE DIRECTORY PER I PROGETTI\n\t\tper iniziare creare una directory di progetto e con la funzione main. es.\n\t\t\tfn main() {\n\t\tmain senza parametri () vuote, e con una macro\n\t\t\tprintln!(\"hello word\");\n\t\tinfatti println senza \t(!) = è una funzione\t\n\t\tinfatti println! con \t(!) = è una MACRO\n\t\t{};\t\t\t\t\t\t\t= le parentesi racchiudono tutte le funzioni e la riga finisce con \n\t\t\t\t\t\t\t\t\til ; perchè Rust è un linguaggio orientato alle ESPRESSIONI infatti\n\t\t\t\t\t\t\t\t\tla maggior parte delle cose sono espressioni e con il ; si dichiara\n\t\t\t\t\t\t\t\t\tla fine della espressione.\n\n\tCOMPILARE ED ESEGUIRE SONO PASSI SEPARATI\n\t\tRust è un linguaggio compilato in anticipo tipo il c++ perchè si ha il sorgente ed un eseguibile\n\t\tsulle piattaform a differenza degli  dei linguaggi dinamici tipo Python dove occore consegnare\n\t\til sorgente .py ma occorre anche la macchina virtuale per l'esecuzione, cià che non serve in rust.\n\t\tLa compilazione con rust c = va bene per i programmi semplici altrimenti occorre usare cargo.\n\n\t\tCARGO\n\t\t\tÈ un sistema di buile e di gestore di pacchetti Rust  per i progetti ed esegue 3 cose:\n\t\t\t\t- compila il codice;\n\t\t\t\t- scarica le librerie;\n\t\t\t\t- e costruisce le librerie;\n\n\t\t\tla versione di cargo è con : cargo --version\n\n\t\t\tCargo utilizza un sistema ad ordine, la directory principale per README + LA LICENZA + I LINK quindi il sorgente va nella directory \n\t\t\t\tsrc\n\n\t\t\tnella src ci sono i sorgenti tipo main.src oppure anche librerie lib.rs\n\n\t\t\tPer gestire con cargo occorre creare una direcotry madre\n\t\t\tuna directory src dove inseire i file sorgenti menetre nella directory principale il Cargo.toml\n\t\t\til toml = Questo file è nel formato TOML (Tom's Obvious Minimal Language). TOML è simile al formato INI, ma ha alcuni vantaggi, e viene usato come formato di configurazione di Cargo.\n\t\t\tDentro questo file, si digiti la seguente informazione:\n\n\t\t\t\t\t[package]\t\t\t\t= \tle seguenti direttive costruiscono un pacchetto\n\n\t\t\t\t\tname = \"hello_world\"\t= il nome del programma\n\t\t\t\t\tversion = \"0.0.1\"\t\t= la versione\n\t\t\t\t\tauthors = [ \"Il tuo nome <tu@esempio.it>\" ] = chi lo ha scritto\n\t\t\t\t\n\t\t\t\thello_word_cargo\n\t\t\t\t\tCargo.toml\n\t\t\t\t\tsrc\n\t\t\t\t\t\tmain.rs\n\n\n\t\t\tCargo viene utilizzato per grandi progetti, perchè  si iniziano ad usare i \"crate\"; questi, in altri linguaggi di programmazione, sono chiamati ‘librerie’ o ‘pacchetti’. \n\n\t\t\tCon cargo per rilasciare il progetto finale occorre questo comando:\n\t\t\t\tcargo build --release\n\t\t\t\t \n\t\t\tcon questa secondo profilo la compilazione è piu lenta ma viene ottimimizzata e velocizzato\n\t\t\til file finale .exe\n\n\t\t\tCARGO LOCK\n\t\t\t\tè il file in cui cargo tiene conto delle dipendenze dell'applicazione.\n\n\n\t\t\tCARGO CREA PROGETTO\n\t\t\t\tper creare un nuovo progetto occorre eseguire questo comando\n\t\t\t\t\tcargo new nome_progetto --bin\n\t\t\t\t\t \t\t\t\t\t\t--bin = opzione per creare direttamente un eseguibile e non\n\t\t\t\t\t \t\t\t\t\t\tuna libreria\n\n\tGIOCO-INDOVINA\n\t\tImpostazione\n\t\t\timposto il nuovo progetto nella directory con il comando\n\t\t\t\tcargo new gioco_indovina --bin\n\t\t\t\t                         --bin = creato un nuovo progetto eseguibile non una libreria.\n\n         Elaborare un tentativo\n         \tElaboraiamo il file main per consentire al giocatore di inserire i tentativi:\n\n         \t\tuse std::io;\t\t= libreria per lo standard io\n         \t\tfn main() { \t\t= e () indicano che non ci sono argomenti,\n         \t\tlet \t\t\t\t= istruzione let, che viene usata per creare ‘legami a variabili’ \n         \t\t\t\t\t\t\t  [variable bindings].\n\n\t\t\t\t  esempio\n\t\t\t\t  \tlet foo = bar;\n\t\t\t\t\t  \tQuesta istruzione crea un nuovo legame chiamato foo, e lo lega al valore bar. In molti linguaggi, questo si chiama ‘variabile’, ma i legami di variabile di Rust hanno alcuni assi nella manica.\n\n\t\t\t\t\t  \tl'istruzione senza mut rende immutabile il legame in quanto di default\n\n\t\t\t\t\t  \t\tlet foo = 5; // immutabile.\n\t\t\t\t\t\t\tlet mut bar = 5; // mutabile\n\n\t\t\t\t\t\tcon l'istruzione \n\t\t\t\t\t\t\t    let mut tentativo = String::new();\n\t\t\t\t\t    viene creata una variabile mutevole di tipo Stringa associata ad un tipo String\n\t\t\t\t\t    e non un nuova istanza di String e quindi è un METODO DI CLASSE o un METODO STATICO.\n\n\t\t\t\t    \tcon l'istruzione\n\t\t\t\t    \t\tio::stdin().read_line(&mut tentativo).expect(\"non si riesce a leggere la riga\");\n\t\t\t\t    \t\tutilizza lo std::io\n\t\t\t\t    \t\t\tstd::io::stdin   = legge l'imput da linea di comando\n\t\t    \t\t    \t\t(&mut tentativo) = imposta la variabile tentativo mutevole con il \t\t\t\t\trisultato\n\t\t    \t\t    \t\t.expect(\"non ..) = visto che anche un Result (io::Result) come primo\n\t\t    \t\t    \t\tcaso generico e anche sottolibreria ma viene utilizzato per il messaggio di errore se si va in panic.\n\n    \t\t    \t\tle {} nella macro sono segna posto\n    \t\t    \t\tQuesta riga stampa la stringa dove abbiamo salvato il nostro input. Le parentesi graffe {} sono dei segna-posto per passare tentativo come argomento. Se avessimo scritto diversi {}, avremmo passato diversi argomenti:\n\n\t\t\t\t\t\t\t\t\tlet x = 5;\n\t\t\t\t\t\t\t\t\tlet y = 10;\n\n\t\t\t\t\t\t\t\t\tprintln!(\"x e y: {} e {}\", x, y);\n\n\tGENERARE UN NUMERO SEGRETO \n\t\tcrate rand\n\t\t\tcassone o scatola oppure libreria che permette per i numeri casuali, nel frattempo viene\n\t\t\tcreato un nuovo progetto per i numero segreto:\n\t\t\t\tmkdir genera_numero_segreto\n\n\t\t\tcon \n\t\t\t\tcargo new numero_segreto --bin \n\n\t\t\tdopo aver creato il progetto per utilizzare la libreria rand occore indicare la dipendenza\n\t\t\tnel toml\n\t\t\t\trand=\"0.3.0\"\n\n\t\t\tdependencies per sapere quali dipendenze ci sono da crate esterni, e quali versioni di essi sono richieste. In questo caso, abbiamo specificato la versione 0.3.0, che Cargo capisce essere qualunque rilascio che è compatibile con questa specifica versione.\n\t\t\tCargo va a prendere le versioni più recenti di ogni cosa dal registry, che è una copia di dati presi da Crates.io. Crates.io è il posto dove la gente nell'ecosistema di Rust invia i suoi progetti open source in Rust per farli usare ad altri.\n\n\t\t\tDopo aver aggiornato il registry, Cargo verifica la nostra sezione [dependencies] e scarica tutti i pacchetti che non abbiamo ancora. In questo caso, mentre abbiamo detto soltanto che volevamo dipendere da rand, ci siamo presi anche una copia di libc. Questo perché rand dipende da libc per funzionare. Dopo averli scaricati, li compila, e poi compila il nostro progetto.\n\t\t\tQuando costruiamo un progetto da zero ed impostiamo la dipendenza ad es. rand=0.3.0, cargo\n\t\t\timposta il Cargo Lock a questa versione e se uscira una successiva tipo  rand=0.3.9 il \n\t\t\tcargo lock impedisce di scacarica la nuova versione per il pericolo della incompatibilita\n\t\t\tretroattiva a meno che non impostiamo a mano il 0.3.9 NEL TOML\n\t\t\tALTERNATIVA per FORZARE IL CARGO.LOCK possiamo usare\n\t\t\t\tcargo update\n\t\t\tche significa ignora il cargo.lock e cerchera di aggiornare le versioni > 0.3.0 and < 0.3.9\n\t\t\tma non la versione 0.4.0 che deve essere esplicitamente impostata nel .toml\n\n\t\t\tper utilizzare rand dopo averlo dichiarato nelle dipendence del .toml\n\t\t\toccore inserire nel file la dichiarazione di utilizzo:\n\t\t\t\textern crate rand;\n\n\n\t\t\tviene inserito \n\t\t\t\tuse std::cmp::Ordering;\n\n\t\t\tSTD::CMP = è un metodo che restituisce un ORDERIN cioè un enum  < = >.\n\t\t\tcmp = viene chiamato per qualunque oggetto da confrontare con riferimento allo\n\t\t\tstesso oggetto da confrontare  e restisce un Ordering.\n\t\t\tOrdering = è un enum con 3 POSSIBILI VARIANTI\n\t\t\t\tLESS, EQUAL, GREATER\n\n\t\t\tserve per confrontare i numeri  e deve essere integrato con un match\n\t\t\t\t\n\t\t\t\tmatch tentativo.cmp(&numero_segreto) {\n\t\t\t\t    Ordering::Less    => println!(\"Troppo piccolo!\"),\n\t\t\t\t    Ordering::Greater => println!(\"Troppo grande!\"),\n\t\t\t\t    Ordering::Equal   => println!(\"Hai vinto!\"),\n\t\t\t\t}\n\n\n\t\t\t\n\t\t\tCONVERSIONE DEL TIPO STRINGA CON PARSE\t\n\n\t\t\t\tIl metodo parse() applicato a una stringa analizza la stringa estraendone un numero di qualche tipo. Dato che tale metodo può riconoscere vari tipi di numeri, dobbiamo suggerire a Rust il tipo esatto del numero che vogliamo. Pertanto, scriviamo let tentativo: u32. I due-punti (:) dopo tentativo dicono a Rust che stiamo annotando il tipo del legame. u32 è il tipo intero senza segno a trentadue bit. \n\t\t\t\t\tfn main() {\n\t\t\t\t        let tentativo: u32 = tentativo.trim().parse()\n\t\t\t\t        .expect(\"Prego, digita un numero!\");\n\t\t\t\t}\n\n\n\t\t\tLOOP\n\t\t\t\tViene creato un loop\n\t\t\t\ted inserito la gestione del panic\n\n\tLEGAMI DI VARIABILE - \t\t\t\t\t\t\t\t4.1\n\t\t\t\n\t\t\tPer introdurre un legame, si usa la parola-chiave let, così:\n\t\t\t\t\tlet x = 5;\n\n\t\t\tI PATTERN - 4.1.1\n\t\t\t\tnegli altri linguaggi si chiama variabile, ma i legami di variabile di Rust hanno alcuni assi nella manica. Per esempio, il lato sinistro di un'istruzione let è un ‘pattern’, non un semplice nome di variabile\n\n\t\t\t\t\t\tlet (x, y) = (1, 2);\n\t\t\t\t\t\tDopo che questa istruzione viene eseguita, x varrà uno, e y varrà due. (vedere i pattern)\n\n\t\t\tANNOTAZIONI DI TIPO - 4.1.2\n\t\t\t\tRust è un linguaggio tipizzato staticamente, il che significa che specifichiamo subito i tipi, e questi vengono verificati in fase di compilazione.\n\t\t\t\tMa rust ha anche la \n\t\t\t\t\tINFERENZA DI TIPO. Se riesce a desumere qual'è il tipo di qualche \n\t\t\t\t\t\t\t\t\t\tdato, Rust non costringe a digitarlo splicitamente.\n\n\t\t\t\tSe vogliamo, possiamo aggiungere il tipo di dato.\n\t\t\t\t\tlet x: i32 = 5;\n\n\t\t\t\tRust ha molti tipi interi primitivi. I loro nomi cominciano con i per gli interi con segno, e con u per gli interi senza segno (unsigned). Le dimensioni intere possibili sono 8, 16, 32, e 64 bit.\n\n\t\t\tMUTABILITÀ\n\t\t\t\tDi default, i legami sono immutabili. Questo codice non compilerà:\n\t\t\t\t\tlet x = 5;\n\t\t\t\t\tx = 10;\n\t\t\t\tSe si vuole che un legame sia mutabile, si deve usare mut:\n\t\t\t\t\tlet mut x = 5; // mut x: i32\n\t\t\t\t\tx = 10;\n\n\t\t\t\tLA RAGIONE PRINCIPALE DELLA IMMUTABILITA DEI LEGAMI E' LA SICUREZZA.\n\t\t\t\tSe ci si dimentica di dire mut, il compilatore se ne accorgerà, e farà sapere che si ha mutato qualcosa che si potrebbe non aver inteso mutare. Se i legami fossero mutabili di default, il compilatore non sarebbe in grado di dirlo. Se si intendesse proprio la mutazione, allora la \n\t\t\t\tsoluzione è facilissima: aggiungere mut.\n\n\t\t\tINIZIALIZZARE I LEGAMI\n\t\t\t\tI legami di variabile in Rust hanno un altro aspetto che differisce da altri linguaggi: I LEGAMI DEVONO ESSERE INIZIALIZZATI CON UN VALORE PRIMA DI POTERLI USARE.\n\t\t\t\tSe utilizziamo ugualmente una variabile senza inizializzabile Rust ci da errore; Rust non ci permetterà di usare un valore che non è stato inizializzato.\n\t\t\t\t\tes.\n\t\t\t\t\t\tfn main() {\n\t\t\t\t\t\t    let x: i32;\n\n\t\t\t\t\t\t   !=macro\n\t\t\t\t\t\t   \t\t\t\t   1°               2°\n\t\t\t\t\t\t   2 argomenti |------------------||--|\n\t\t\t\t\t\t    println!(\"Il valore di x è: {}\", x);\n\t\t\t\t\n\t\t\t\t\tRust non ci permetterà di usare un valore che non è stato inizializzato.\n\t\t\tINTERPOLAZIONE STRINGA\n\t\t\t\t\t@interpolazione_(la @interporabilita della stringa è l'inserimento\n\t\t\t\t\t\tdi una stringa all'interno di un'altra stringa,)\n\t\t\t\t\t@{}_(le @grasse sono dei @segnaposto per dire dopo la virgola interpoliamo il valore)\n\n\t\t\t\tprintln!(\"Il valore di x è: {}\", x); utilizza l'interpolazione stringa ossia l'inserimento di una stringa all'interno di un'altra stringa al posto di altrettanti segnaposto. Infatti le {} sono dei segnaposto per cui viene detto a rust dopo la stringa tipo :\n\t\t\t\t\t\"Il valore di x è: {}\",  = indichiamo a rust che dopo la virgola (,)\n\t\t\t\t\tinterpoliamo il valore di x e la virgola serve a separare gli argomenti che passiamo alle funzioni e alle macro.\n\n\n\t\t\tAMBITO ED OSCURAMENTO\n\t\t\t\tI legami di variabile hanno un ambito - ossia sono vincolati a risiedere nel blocco in cui sono stati definiti. \n\t\t\t\tUn blocco è una collezione di istruzioni racchiuse da { e }. Anche le definizioni di funzione sono blocchi! \n\n\t\t\t\tNell'esempio seguente definiamo due legami di variabile, x e y, che risiedono in blocchi diversi. Si può accedere a x da tutto il blocco fn main() {}, mentre si può accedere a y solamente dal blocco più interno:\n\n\t\t\t\t\t\tfn main() { //I° BLOCCO GRAFFE\n\t\t\t\t\t\t    let x: i32 = 17;\n\n\t\t\t\t\t\t    //II° BLOCCO GRAFFE SEPARATO\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t        let y: i32 = 3;\n\t\t\t\t\t\t        println!(\"Il valore di x è {} e il valore di y è {}\", x, y);\n\t\t\t\t\t\t    }\n\n\t\t\t\t\t\t    //non puoi stampare x\n\t\t\t\t\t\t    println!(\"Il valore di x è {} e il valore di y è {}\", x, y); // Questo non funziona Y non accessibile\n\t\t\t\t\t\t}\n\t\t\t\tLa prima println! stamperebbe \"Il valore di x è 17 e il valore di y è 3\", ma questo esempio non può essere compilato con successo, perché la seconda println! non può accedere al valore di y, dato che non è più nel suo ambito. Otteniamo invece questo errore:\n\n\n\n\n\t\t\t\tOSCURAMENTO - SHADOWED\n\t\t\t\t \tInoltre, i legami di variabile possono venire oscurati (\"shadowed\"). Ciò significa che un successivo legame di variabile con il medesimo nome di un legame attualmente nel suo ambito scavalcherà il legame precedente.\n\n\t\t\t\t\tlet x: i32 = 8;\n\t\t\t\t\t{\n\t\t\t\t\t    println!(\"{}\", x); // Stampa \"8\"\n\t\t\t\t\t    let x = 12; \t   //OSCURA LA X =8 \n\t\t\t\t\t    println!(\"{}\", x); // Stampa \"12\"\n\t\t\t\t\t}\n\t\t\t\t\tprintln!(\"{}\", x); // Stampa \"8\"\n\t\t\t\t\tlet x =  42;       //OSCURA LA X =8 \n\t\t\t\t\tprintln!(\"{}\", x); // Stampa \"42\"\n\n\t\t\t\t\tATTENZIONE l'ocsuramento lega un nome ad un valore diverso ed è ammissibile il mut (es. x = 5 poi shadowe = x=\"pippo\" è un testo non un numero)\n\t\t\t\t\t\t@oscuramento_(è possibile il mutamento? si NON VIENE DISTRUTO MA NON E' ACCESSIBILE)\n\t\t\t\t\tl'oscuramento non alter o distrugge il valore ma continua ad esistere\n\t\t\t\t\tfinche non esce dall'ambito MA NON E' ACCESSIBILE.\n\t\t\t\t\t\tES.\n\t\t\t\t\t\t\tlet mut x: i32 = 1;\n\t\t\t\t\t\t\tx = 7;\n\t\t\t\t\t\t\tlet x = x; // x adesso è immutabile ed è legato a 7\n\n\t\t\t\t\t\t\tlet y = 4;\n\t\t\t\t\t\t\tlet y = \"Posso anche essere legato a un testo!\"; // y adesso è di un altro tipo\n\n\tFUNZIONI \t\t\t\t\t\t\t\t\t\t\t4.2\n\t\tMAIN\n\t\t\t\t\t@funzioni_(nelle funzioni i @parametri devono essere dichiarati )\n\n\t\t\tOgni programma Rust ha almeno una funzione, la funzione main:\n\n\t\t\t\tfn main() {\n\t\t\t\t}\n\n\t\t\tNO ARGOMENTI\n\t\t\t\tQuesto è la dichiarazione di funzione più semplice possibile. Come accennato prima, fn indica che ‘questa è una funzione’, ed è seguita dal nome della funzione, da due parentesi vuote perché questa funzione non prende argomenti, e poi da parentesi graffe che contengono il corpo della funzione. Ecco una funzione chiamata foo:\n\n\t\t\t\t\tfn foo() {\n\t\t\t\t\t}\n\n\t\t\tPARAMETRI\n\t\t\t\tfn main() {\n\t\t\t\t\t\t//chiamo la funzione e passo il parametro\n\t\t\t\t\t    stampa_numero(5);\n\t\t\t\t\t}\n\n\t\t\t\t\t//creato fuori main la funzione con 1 parametro\n\t\t\t\t\tfn stampa_numero(x: i32) {\n\t\t\t\t\t    println!(\"x is: {}\", x);\n\t\t\t\t\t}\n\n\t\t\tNOME + TIPO ARGOMENTO\n\t\t\t\tNote\n\t\t\t\t\tCome si vede, gli argomenti delle funzioni funzionano in modo molto simile alle dichiarazioni let: si aggiunge un tipo al nome dell'argomento, dopo i due punti :.\n\n\t\t\t\t\tEcco un programma completo che somma due numeri e stampa il risultato:\n\n\t\t\t\t\t\tfn main() {\n\t\t\t\t\t\t    stampa_somma(5, 6); //Virgola quando chiamo la funzione\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//\t\t\tla funzione è esterna a main\n\t\t\t\t\t\t//--------------------------------------------------------------//\n\t\t\t\t\t\t//x: i32 = NOME+TIPO ..., passo 2 argomenti numerici x,y\n\t\t\t\t\t\tfn stampa_somma(x: i32, y: i32) { //virgola quando dichiaro la funzione\n\t\t\t\t\t\t\t\t\t\t\t\t\t   //\t\n\t\t\t\t\t\t    println!(\"la somma è: {}\", x + y);\n\t\t\t\t\t\t}\n\n\t\t\t\tLA VIRGOLA\n\t\t\t\t\tSi separano gli argomenti usando una virgola, sia quando si chiama la funzione, che quando la si dichiara.\n\n\t\t\t\tOBBLIGATORIA LA DICHIARAZIONE DEI TIPI\n\t\t\t\t\tDiversamente dall'istruzione let, i tipi degli argomenti delle funzioni devono essere dichiarati. Pertanto questo non funziona:\n\n\t\t\t\t\t\t\tfn stampa_somma(x, y) {\n\t\t\t\t\t\t\t    println!(\"la somma è: {}\", x + y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSi ottiene l'errore:\n\t\t\t\t\t\t\t\tprevisto 1 tra  ! o @ ..\n\t\t\t\t\t\t\t\texpected one of `!`, `:`, or `@`, found `)`\n\t\t\t\t\t\t\t\t\tfn print_sum(x, y) {\n\n\t\t\t\tINFERENZA\n\t\t\t\t\t\t\t@inferenza_(determinazione del tipo di dato non dichiarato)\n\n\t\t\t\t\t\tE' una attivita in cui il compilatore  usa l'inferenza dei tipi  per determinare i tipi di dati delle variabili locali dichiarate senza un Tipo. Il compilatore inferisce il tipo della variabile dal tipo dell'espressione di inizializzazione. Ciò consente di dichiarare le variabili senza specificare in modo esplicito un tipo, come illustrato nell'esempio seguente. Come risultato delle dichiarazioni, entrambe num1 e num2 sono fortemente tipizzata come interi.\n\t\t\t\t\t\t\t   ' //esempio IN VB\n\t\t\t\t\t\t\t\t    Dim num1 As Integer = 3\n\n\t\t\t\t\t\t\t\t    ' Using local type inference.\n\t\t\t\t\t\t\t\t    Dim num2 = 3  //inferenza il compilatore comprende che è un intero\n\n\t\t\t\t\t\t\t\t//il vb all'interno della funzione @INFERENZA    \n\t\t\t\t\t\t\t\tPublic Sub inferenceExample()\n\n\t\t\t\t\t\t\t\t    ' Using explicit typing. - tipo dichiarato\n\t\t\t\t\t\t\t\t    Dim num1 As Integer = 3\n\n\t\t\t\t\t\t\t\t    ' Using local type inference. \n\t\t\t\t\t\t\t\t    Dim num2 = 3  //imposta come intero simile al tipo dichiarato perchè all'interno della funzione\n\n\t\t\t\t\t\t\t\tEnd Sub\n\n\t\t\t\t\t    In Rust L'INFERENZA è applicata all'interno del { corpo delle\n\t\t\t\t\t    \tfunzioni }, mentre è OBBLIGATORIA LA DICHIARAZIONE DEI TIPI\n\t\t\t\t\t    \tnella DEFINIZIONE DELLE FUNZIONI.\n\n\t\t\t    VALORE DI RITORNO DELLA FUNZIONE\n\t\t\t    \t\t\t@funzioni_(il valore di @ritorno con @->)\n\t\t\t    \t\tLe funzioni di Rust restituiscono esattamente un valore, e si dichiara il tipo dopo una ‘freccia’, che è un trattino (-) seguito da un segno di maggiore (>). L'ultima riga di una funzione determina che cosa restituisce. Qui si noterà la mancanza di un punto-e-virgola. Se l'avessimo aggiunto:\n\n\t\t\t\t\t\t\t\t\tfn somma_uno(x: i32) -> i32 {\n\t\t\t\t\t\t\t\t\t    x + 1 // senza il; permette il valore di ritorno altrimenti errore\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\tESPRESSIONI CONTRO ISTRUZIONI\n\t\t\t\t\t\t@istruzioni_(in rust son di due tipi istruzioni quelle che restiscono un valore e quelle no. )\n\n\t\t\t\t\t\t@istruzioni@espressioni_(in rust restituiscono una tupla)\n\n\t\t\t\tESPRESSIONI ED ISTRUZIONI DIFFERENZA\n\n\t\t\t\t\tRust è primariamente un linguaggio basato sulle espressioni. Ci sono solamente due tipi di istruzioni, e ogni altra cosa è un'espressione.\n\n\t\t\t\t\tla differenza è che:\n\t\t\t\t\t\tespressioni = restiscono un valore\n\t\t\t\t\t\tistruzioni\t= non restituiscono valori\n\t\t\t\t\t\t\tl'istruzione x + 1; non restituisce un valore. \n\n\t\t\t\tISTRUZIONI\n\t\t\t\t\tci sono due tipi di istruzioni:\n\n\t\t\t\t\t\tISTRUZIONE DI DICHIARAZIONE = con Let \n\t\t\t\t\t\tISTRUZIONE DI ESPRESSIONE \t= trasforma qualsiasi istruzione in \n\t\t\t\t\t\t\t\t\t\t\t\t\tuna espressione; significa che rust si aspetta da ogni istruzione segua un'altra istruzione.\n\t\t\t\tISTRUZIONE DI DICHIARAZIONE\n\n\t\t\t\t\tin altri linguaggi esempio in Ruby pui creare espressioni e fare il \n\t\t\t\t\tlegame delle variabili es.\n\t\t\t\t\t\t x = y =5;  //Ruby si puo' creare una espressione\n\n\t\t\t\t    In Rust in non è ammesso il legame delle variabile con una espressione es:\n\t\t\t\t    \tlet x = (let y = 5); // atteso un identificatore, trovata la parola-chiave `let` - produce errore.\n\n\t\t\t    \tMa rust utilizza let per attivare una istruzione e quindi non si puo assegnare come negli altri linguaggi con let una espressione, perche a differenza degli altri linguaggi con con l'istruzione:\n\t\t\t    \t\tx = y = 5\n\t\t\t    \t\tx ha 5 assegnato da y\n\t\t    \t\tnel caso di rust\n\t\t    \t\t\tlet x = (let y = 5); // da errore in quanto  x non ha il valore\n\t\t    \t\t\tdi y  perche in:\n\t\t    \t\t\t\tRust = si ha un solo possessore  e quindi 5 non puo essere\n\t\t    \t\t\t\tassegnato sia a y e sia ad x quindi in questo caso viene dato un errore.\n    \t\t\t\tnel caso invece di una istruzione di dichiarazione del tipo\n    \t\t\t\t\tlet mut y = 5\n    \t\t\t\t\tlet x = (y=6);\n    \t\t\t\t\t    x = ha valore di tupla vuota non di 6 mentre y contiene il 6.\n\n\t\t\t    ISTRUZIONE DI ESPRESSIONE\n\t\t\t    \tle istruzioni di espressione il II tipo di istruzione, servono a Rust per trasformare QUALUNQUE ESPRESSIONE IN UNA ISTRUZIONE.\n\t\t\t    \tPerchè rust si aspetta che ad ogni istruzione segua un'altra istruzione sempre separata da un ;\n\t\t\t    \t\n\t\t\t    \tUNICA ECCEZIONE AL ; è quando costruiamo una funzione che restituisce\n\t\t\t    \tun valore nel cui corpo viene omessa il punto e virgola (;) perche è\n\t\t\t    \tun valore di ritorno es.\n\t\t\t    \t\tfn somma_uno (x: i32) {\n\t\t    \t\t\t\tx+1  //senza ; restituisce il valore incrementato\n\t\t\t    \t\t}\n\n\t\t    \t\t\t\t.\n    \t\t\t\te quindi in rust L'ISTRUZIONE DI ESPRESSIONE è sempre una istruzione di assegnamento e non di espressione in quanto anche un codice di questo tipo:\n    \t\t\t\t\tlet mut y = 5;  //creo y mutubile\n\n\t\t\t\t\t\tlet x = (y = 6);  // x ha valore `()`, non `6`\n    \t\t\t\t \n    \t\t\t\t let x è un tupla vuota ma non 6 non è un risutato di una espression\n    \t\t\t\t di y che assegna a x, MA UNA ISTRUZIONE CHE ASSEGNA A X UNA TUPLA VUOTA.\n    \t\t\t\t mentre y è uguale a 6.\n\n    \t\t\t\t conclusione in rust ci sono istruzioni di assegnazioni o istruzioni di espressione, mentre tutto il resto sono espressioni.\n\n\n\t\t\t\tUSCITE PRECOCI\n\t\t\t\t\tcon la parola chiave return\n\t\t\t\t\t\tfn foo(x: i32) -> i32 {\n\t\t\t\t\t\t    return x;\n\n\t\t\t\t\t\t    // non si eseguirà mai questo codice!\n\t\t\t\t\t\t    x + 1\n\t\t\t\t\t\t}\n\n\t\t\t\t\toppure con stile elegante:\n\t\t\t\t\t\tfn foo(x: i32) -> i32 {\n\t\t\t\t\t\t\t\t    return x + 1;\n\t\t\t\t\t\t\t\t}\n\n\t\t\tFUNZIONI DIVERGENTI\n\n\t\t\t\tsono le funzioni che non restituiscono mai il controllo al chiamante:\n\n\t\t\t\t\tfn diverge() -> ! {\n\t\t\t\t\t    panic!(\"Questa funzione non restituisce mai il controllo al chiamante!\");\n\t\t\t\t\t}\n\n\t\t\t\t\tpanic! è una macro, come lo è println!() che abbiamo già visto. Diversamente da println!(), panic!() manda in crash il thread corrente, stampando il messaggio ricevuto come argomento. Dato che questa funzione provocherà un crash, non restituirà mai il controllo al chiamante, e quindi ha il tipo ‘!’, che si legge ‘diverge’\n\n\n\t\t\t\tSe si aggiunge una funzione main che chiama diverge() e la si esegue, si otterrà un output simile a questo:\n\t\t\t\t\tthread ‘main’ panicked at ‘Questa funzione non restituisce mai il controllo al chiamante!’, main.rs:2\n\n\t\t\t\tUna funzione divergente può essere usata dove ci si aspetta un'espressione di qualunque tipo:\n\n\t\t\t\t\t\tlet x: i32 = diverge();\n\t\t\t\t\t\tlet x: String = diverge();\n\t\t\t\n\t\t\tPUNTATORI DI FUNZIONE\n\t\t\t\t\t@puntatori_(a @funzione con @interferenza o senza)\n\n\t\t\t\tPossiamo anche creare legami di variabili che puntano a funzioni:\n\t\t\t\t\t\n\t\t\t\t\tlet f: fn(i32) -> i32;\n\n\t\t\t\tf è un legame di variabile che punta a una funzione che prende un i32 come argomento e restituisce un i32. Per esempio:\n\t\t\t\t\t\n\t\t\t\t\tfn piu_uno(i: i32) -> i32 {\n\t\t\t\t\t\t    i + 1\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// senza l'inferenza di tipo\n\t\t\t\t\t\tlet f: fn(i32) -> i32 = piu_uno;\n\n\t\t\t\t\t\t// con l'inferenza di tipo\n\t\t\t\t\t\tlet f = piu_uno;\n\t\t\t\t\t\t\t\n\t\t\t\tPoi possiamo usare f per chiamare la funzione:\n\t\t\t\t\tlet sei = f(5);    //variabile che punta alla funzione f e la chiama \t\t\t\t\te poi assegna il risultato a sei.\n\n\tTIPI PRIMITIVI \t\t\t\t\t\t\t\t\t\t4.3\n\t\tNote\n\t\t\t\tIl linguaggio Rust ha vari tipi che sono considerati ‘primitivi’. Ciò significa che fanno parte del linguaggio. Rust è strutturato in modo tale che la libreria standard fornisca anche vari altri tipi utili, costruiti basandosi su quelli primitivi, ma quelli che vedremo sono i più primitivi.\n\n\t\tBooleani \t\t\t\t\t\t\t4.3.1\n\t\t\tRust ha un tipo booleano primitivo, chiamato bool. Ha solo due valori, true (\"vero\") e false (\"falso\"):\n\n\t\t\t\tlet x = true;\n\n\t\t\t\tlet y: bool = false;\n\t\t\t\tNella documentazione della libreria standard si trova ulteriore documentazione sui bool.\n\n\n\t\t\t\tI booleani sono usati tipicamente nei costrutti if.\n\t\tchar \t\t\t\t\t\t\t\t4.3.2\n\t\t\tIl tipo char rappresenta un singolo valore scalare Unicode. Si possono creare dei char racchiudendoli tra apici singoli: (')\n\t\t\t\t\tlet x = 'x';\n\t\t\t\t\tlet two_hearts = '💕';\n\t\t\t\t\tDiversamente da alcuni altri linguaggi, ciò significa che il char di Rust non è rappresentato con un singolo byte, ma da quattro byte.\n\n\t\tTipi numerici\t\t\t\t\t\t4.3.3\n\n\t\t\tNote\n\t\t\t\tRust ha parecchi tipi numerici, appartenenti alle seguenti categorie: con segno e senza segno, fissi e variabili, a virgola mobile e interi.\n\n\t\t\t\tQuesti tipi consistono di due parti: la categoria, e la dimensione. Per esempio, u16 è un tipo senza segno con una dimensione di sedici bit. Più bit consentono di rappresentare numeri più grandi.\n\n\t\t\t\tSe un letterale numerico non specifica il tipo esatto a cui appartiene, il suo tipo viene inferito nel seguente modo:\n\n\t\t\t\tEcco una lista dei diversi tipi numerici, con dei link alla loro documentazione nella libreria standard:\n\n\t\t\t\t\ti8\n\t\t\t\t\ti16\n\t\t\t\t\ti32\n\t\t\t\t\ti64\n\t\t\t\t\tu8\n\t\t\t\t\tu16\n\t\t\t\t\tu32\n\t\t\t\t\tu64\n\t\t\t\t\tisize\n\t\t\t\t\tusize\n\t\t\t\t\tf32\n\t\t\t\t\tf64\n\t\t\t\t\tEsaminiamoli in base alla loro categoria:\n\n\t\tCon segno e senza segno \t\t\t4.3.4\n\t\t\tCi sono due categorie di tipi interi: \n\t\t\t\t- con segno \t= da -8 a + 7\n\t\t\t\te \n\t\t\t\t- senza segno \t= 0 a +15 (no rappresenta i negativi)\n\t\t\tPer comprendere la differenza, consideriamo un numero di quattro bit. \n\n\t\t\tUn numero di quattro bit, con segno, consentirebbe di rappresentare i numeri da -8 a +7. \n\t\t\tI numeri con segno usano la \"rappresentazione in complemento a due\". \n\n\t\t\tUn numero di quattro bit, senza segno, dato che non ha bisogno di rappresentare valori negativi, può rappresentare valori da 0 a +15.\n\n\t\tTipi a dimensione fissa \t\t\t4.3.5\n\t\t\tI tipi dimensione fissa hanno uno specifico numero di bit nella loro rappresentazione. Le dimensioni in bit valide sono :\n\t\t\t\t8, 16, 32, e 64. \n\t\t\tPerciò, u32 è un intero senza segno, a 32 bit, e i64 è un intero con segno, a 64 bit.\n\n\t\tTipi a dimensione variabile \t\t4.3.6\n\t\t\t\t\n\t\t\t\t@usize_{dimensione dipende dall'architettura}\n\n\t\t\tRust fornisce anche dei tipi la cui effettiva dimensione dipende dall'architettura della macchina in questione. L'ampiezza di questi tipi è sufficiente ad esprimere la dimensione di qualunque collezione, perciò questi tipi appartengono alla categoria ‘size’ ('dimensione'). Anche loro hanno la versione con segno e quella senza segno, e quindi sono due: isize e usize.\n\n\t\tTipi a virgola mobile \t\t\t\t4.3.7\n\t\t\t\t@float_(numeri a @virgola @mobile con @f32 e @f64 sono a @precisione @singola o @doppia)\n\n\t\t\tRust ha anche due tipi a virgola mobile: f32 e f64. Questi corrispondono rispettivamente ai numeri a precisione singola e a precisione doppia secondo lo standard IEEE-754.\n\n\t\tArrays \t\t\t\t\t\t\t\t4.3.8\n\t\t\t\t@array_(@array@fisso o schiera per seguenze di dati o lista  a lunghezza fissa, si distingue dal vettore perche esso è dinamico mentre il semplice @array è fisso = alloca nello stack)\n\n\t\t\tCome molti linguaggi di programmazione, Rust ha dei tipi compositi per rappresentare sequenze di dati. Il più basilare è il tipo array (\"schiera\"), una lista a lunghezza fissa di elementi dello stesso tipo. Di default, gli array sono @immutabili.\n\t\t\t\tlet a = [1, 2, 3]; // a: [i32; 3]\n\t\t\t\tlet mut m = [1, 2, 3]; // m: [i32; 3]\n\n\t\t\tGli arrays hanno tipo [T; N]. \n\t\t\tParleremo di questa notazione T nella [sezione sulla genericità][generics]. La N è una costante nota in fase di compilazione, che indica il numero di oggetti contenuto nell'array.\n\n\t\t\tC'è un'abbreviazione per inizializzare ogni elemento di un array allo stesso valore. Ecco come inizializzare a 0 ognuno dei 20 elementi dell'array a:\n\n\t\t\t\tlet a = [0; 20]; // a: [i32; 20] attenzione con il ; resetta tutti a 20 a \n\t\t\t\t\t\t\t\t\t\t\t\t zero\n\n\t\t\tSi può ottenere il numero di elementi di un array a con l'espressione a.len(): \n\t\t\t\tlet a = [1, 2, 3];\n\n\t\t\t\tprintln!(\"a ha {} elementi\", a.len());\n\n\t\t\tSi può accedere a un particolare elemento di un array con la notazione a indice:\n\t\t\t\t\t@accesso_(@elemento di un @array con l)\n\n\t\t\t\tlet nomi = [\"Graydon\", \"Brian\", \"Niko\"]; // nomi: [&str; 3]\n\n\t\t\t\tprintln!(\"Il secondo nome è: {}\", nomi[1]);\n\n\t\t\tGli indici partono da zero, come nella maggior parte dei linguaggi di programmazione, e perciò il primo nome è nomi[0] e il secondo nome è nomi[1]. L'esempio precedente stampa Il secondo nome è: Brian. Provando ad usare un indice non compreso nell'array, si ottiene un errore, perché per ogni accesso ad un array, in fase di esecuzione si verifica che l'indice sia compreso nei limiti. Accessi erronei di questo tipo causano molti bug in altri linguaggi di programmazione di sistema.\n\n\t\tSlices (\"@Fette\")\t\t\t\t\t4.3.9\n\n\t\t\t\t@slice_(sono viste dentro una struttura come una parte di array ed un putnatore all'inizio dei dati)\n\n\t\t\tLe ‘slices’ (pronunciato \"slaises\") sono riferimenti a (o “viste\" dentro) un'altra struttura dati. Servono a consentire un accesso sicuro ed efficiente ad una porzione di un array senza fare copie. Per esempio, si potrebbe voler far riferimento solamente ad una riga di un file letto in memoria. Per sua natura, una slice non viene creata direttamente, ma partendo da un legame di variabile esistente. Le slices hanno una lunghezza fissa, e il loro contenuto può essere mutabile o immutabile.\n\n\t\t\tInternamente, le slice sono rappresentate come un @puntatore all'inizio dei dati e una lunghezza.\n\n\n\n\t\t\tSintassi delle @slices\t\t\t4.4.9.1\n\n\t\t\t\tPer creare una slice da vari oggetti si può usare la combinazione del carattere @& e della coppia di caratteri @[]. Il carattere & indica che le slices sono simili ai [riferimenti], che tratteremo in dettaglio più avanti in questa sezione. La coppia di caratteri [], utilizzata con un range, permette di definire la lunghezza della slice:\n\n\t\t\t\t\tlet a = [0, 1, 2, 3, 4];\n\t\t\t\t\tlet completo = &a[..]; // Una slice contenente tutti gli elementi di a\n\t\t\t\t\tlet mezzo = &a[1..4]; // Una slice contenente solo gli elementi 1, 2, e 3\n\n\t\t\t\tLe slice sono di tipo &[T]. Parleremo di quella T quando tratteremo la genericità.??\n\n\n\t\t\tstr \t\t\t\t\t\t\t4.4.9.2\n\t\t\t\tIl tipo @str di Rust è il tipo di stringa più primitivo. Come tipo unsized, non è molto utile di suo, ma diventa utile quando è utilizzato come riferimento, come per esempio &str. Tratteremo l'argomento in maniera più approfondita quando tratteremo le Stringhe e i riferimenti.\n\n\t\tEnnuple \t\t\t\t\t\t\t4.3.10\n\t\t\tdefinizione\n\t\t\t\tUna ennupla è una lista ordinata di lunghezza fissa. Come questa:\n\t\t\t\t\tlet x = (1, \"ciao\");\n\t\t\t\t\t\t     //lista ordinara 1, ciao nelle ennuple conta l'ordine e\n\t\t\t\t\t\t     possono essere eterogenee\n\n\n\t\t\t\t\tLe parentesi e le virgole formano questa ennupla di lunghezza due. Ecco lo stesso codice, ma con il tipo annotato:\n\n\t\t\t\t\t\tlet x: (i32, &str) = (1, \"ciao\");\n\n\t\t\t\t\tCome si vede, il tipo di una ennupla somiglia all'ennupla, ma in ogni posizione c'è il tipo invece del valore. I lettori attenti noteranno anche che le ENNUPLE SONO ETEROGENEE: in questa ennupla c'è un i32 e un &str. Nei linguaggi di programmazione di sistema, le stringhe sono un pochino più complesse che negli altri linguaggi. Per adesso, si legga &str come slice di stringa, presto impareremo di più a riguardo.\n\n\t\t\t\t\tBIN FRA ENNUPLE\n\t\t\t\t\t\tÈ possibile assegnare un bind su una ennupla ad un'altra ennupla, se entrambe le ennuple contengono gli stessi tipi di dato e hanno la stessa arity (STESSO NUMERO DI ARGOMENTI E STESSA LUNGHEZZA). Le tuple hanno la stessa arity quando hanno la stessa lunghezza.\n\n\t\t\t\t\t\t\t\t//Bind tra ennuple con gli stessi argomenti e stessa lunghezza\n\t\t\t\t\t\t\t\tlet mut x = (1, 2); // x: (i32, i32)\n\t\t\t\t\t\t\t\tlet y = (2, 3); // y: (i32, i32)\n\n\t\t\t\t\t\tSi può accedere ai campi di una ennupla usando un let destrutturante. Ecco un esempio:\n\n\t\t\t\t\t\t\t//pattern dx = sx assegni piu legami\n\t\t\t\t\t\t\tlet (x, y, z) = (1, 2, 3);\n\n\t\t\t\t\t\t\tprintln!(\"x is {}\", x);\n\n\t\t\t\t\t\t\t\tx = y;\n\n\t\t\t\t\t\tQuesto pattern è molto efficace, e lo ritroveremo ripetuto in seguito.\n\n\t\t\t\t\t\tPer discriminare una ennupla con un solo elemento da un valore tra parentesi, basta usare una virgola:\n\n\t\t\t\t\t\t(0,); // ennupla con un solo elemento\n\t\t\t\t\t\t(0); // zero tra parentesi\n\n\t\t\tIndicizzazione delle ennuple \t4.4.10.1\n\t\t\t\t\tI campi di una ennupla possono essere acceduti anche con la sintassi di indicizzazione:\n\n\t\t\t\t\t\tlet ennupla = (1, 2, 3);\n\n\t\t\t\t\t\tlet x = ennupla.0;\n\t\t\t\t\t\tlet y = ennupla.1;\n\t\t\t\t\t\tlet z = ennupla.2;\n\n\t\t\t\t\t\tprintln!(\"x contiene {}\", x);\n\n\t\t\t\t\t\t@differenza@indicizazione_(nelle ennuple l'indicizzazione si fa con il . negli array con le [])\n\t\t\t\t\tL'indicizzazione, come per gli di array, parte da zero, ma diversamente dall'indicizzazione di array, usa un carattere ., invece della coppia di caratteri [].\n\t\tFunzioni\n\t\t\t\t\t\t@puntatore@a@funzione_(puntatore a funzione che restituisce un valore )\n\t\t\t\t\tAnche le funzioni hanno un tipo! Ecco un esempio:\n\t\t\t\t\t\t//creo la funzione foo\n\t\t\t\t\t\tfn foo(x: i32) -> i32 { x }\n\n\t\t\t\t\t\t//let x: fn(i32) = crea un puntatore a funzione che restituisce un i32\n\t\t\t\t\t\tlet x: fn(i32) -> i32 = foo;\n\n\t\t\t\t\tIn questo caso, x è un ‘puntatore a funzione’ che punta a una funzione che prende un i32 e restituisce un i32.\n\n\tCOMMENTI \t\t\t\t\t\t\t\t\t\t\t4.4\n\t\tNote\n\n\t\t\t\t@commenti_(come annotazione e come @documentazione)\n\n\t\t\tI commenti sono annotazioni che si lasciano per gli altri programmatori, per aiutarli a spiegare il proprio codice. Il compilatore per lo più li ignora.\n\n\t\t\tRust ha due tipi di commenti a cui si dovrebbe essere interessati: i commenti di riga e i commenti di documentazione [\"doc comment\"].\n\t\t\t// I commenti di riga sono i caratteri tra la coppia di caratteri ‘//’ e la fine della riga.\n\n\n\t\t\tlet x = 5; // anche questo è un commento di riga\n\n\t\t\t// Se si ha una lunga spiegazione da scrivere, si possono mettere più\n\t\t\t// commenti di riga, uno dopo l'altro. Mettere uno spazio tra // e il testo\n\t\t\t// rende più leggibile il commento.\n\n\t\t\tL'altro genere di commenti è il commento di documentazione. I commenti di documentazione usano /// invece di //, e supportano la notazione Markdown al loro interno:\n\t\t\t\t\t\t/// Aggiunge uno al numero dato.\n\t\t\t\t\t\t///\n\t\t\t\t\t\t/// # Esempi\n\t\t\t\t\t\t///\n\t\t\t\t\t\t/// ```\n\t\t\t\t\t\t/// let cinque = 5;\n\t\t\t\t\t\t///\n\t\t\t\t\t\t/// assert_eq!(6, somma_uno(5));\n\t\t\t\t\t\t/// # fn somma_uno(x: i32) -> i32 {\n\t\t\t\t\t\t/// #     x + 1\n\t\t\t\t\t\t/// # }\n\t\t\t\t\t\t/// ```\n\t\t\t\t\t\tfn somma_uno(x: i32) -> i32 {\n\t\t\t\t\t\tx + 1\n\t\t\t\t\t\t}\n\n\t\t\tC'è un altro stile di commento di documentazione, //!, usato per commentare gli elementi (per es. crate, moduli, o funzioni) che contengono tali commenti, invece che per commentare gli elementi che li seguono. Sono usati tipicamente all'interno delle radici di crate (lib.rs) o delle radici di moduli (mod.rs):\n\n\t\t\t\t//! # The Rust Standard Library\n\t\t\t\t//!\n\t\t\t\t//! The Rust Standard Library provides the essential runtime\n\t\t\t\t//! functionality for building portable Rust software.\n\n\t\t\t\tQuando si scrivono commenti di documentazione, fornire degli esempi di utilizzo è di enorme aiuto. Si noterà che qui abbiamo usato una nuova macro: \n\t\t\t\t\t@assert_eq!. \n\t\t\t\tQuesta macro confronta due valori, e va in panic! se non sono uguali tra di loro. È di grande aiuto nella documentazione. C'è un'altra macro, \n\t\t\t\t\tassert!, \n\t\t\t\tche va in panic! se il valore passatole vale false.\n\n\t\t\t\tSi può usare lo strumento @rustdoc per generare @documentazione @HTML da questi commenti di documentazione, e anche per eseguire gli esempi di codice come collaudo!\n\n\t\tCREARE LA LIBRERIA COMMENTI\n\t\t\tAttenzione per creare la libreria in html occorre la funzione sia pubblica,\n\t\t\t\t1) es. \n\t\t\t\t\t//!main procedura prodotta con cargo.\n\t\t\t\t\t//! # The Rust Standard Library\n\t\t\t\t\t//!\n\t\t\t\t\t//! The Rust Standard Library provides the essential runtime\n\t\t\t\t\t//! functionality for building portable Rust software.\n\n\t\t\t\t\tpub fn main() {\n\t\t\t\t\t\t\n\t\t\t\t\t\tprintln!(\"hello word\");\n\t\t\t\t\t}\n\n\t\t\t\t2) PER CREARE LA LIBRERIA DIGITARE\n\t\t\t\t\tcargo doc\n\t\t\t\t\t\tcrea la libreria html in target/doc ... con html\n\t\t\t\t\tcargo doc --verbose = per visualizzarlo sul terminale\n\n\tIF \t\t\t\t\t\t\t\t\t\t\t\t\t4.5\n\t\tNota\n\t\t\t\t@if_(la if e la @elseif )\n\n\t\t\tE semplice\n\t\t\tNel caso dell'if, c'è un valore booleano che conduce a due strade:\n\n\t\t\t\tlet x = 5;\n\n\t\t\t\tif x == 5 {\n\t\t\t\t    println!(\"x vale cinque!\");\n\t\t\t\t}\n\n\t\t\tSe cambiamo il valore di x a qualcos'altro, questa riga non verrebbe stampata. Più specificamente, se l'espressione dopo l'if vale true, allora il blocco viene eseguito; se vale false, no.\n\t\t\tSe si vuole che accada qualcosa caso false, si usa una clausola else:\n\n\t\t\t\tlet x = 5;\n\n\t\t\t\tif x == 5 {\n\t\t\t\t    println!(\"x vale cinque!\");\n\t\t\t\t} else {\n\t\t\t\t    println!(\"x non vale cinque :(\");\n\t\t\t\t}\n\n\t\t\tELSEIF\n\t\t\t\tIf c'è più di un caso, si usa un else if:\n\n\t\t\t\tlet x = 5;\n\n\t\t\t\tif x == 5 {\n\t\t\t\t    println!(\"x vale cinque!\");\n\t\t\t\t} else if x == 6 {\n\t\t\t\t    println!(\"x vale sei!\");\n\t\t\t\t} else {\n\t\t\t\t    println!(\"x non vale né cinque né sei :(\");\n\t\t\t\t}\n\n\t\t\t\tCiò funziona perché l'if è un'espressione. Il valore di tale espressione è il valore dell'ultima espressione della diramazione scelta. Un if senza un else ha sempre il valore ().\n\n\tCICLI \t\t\t\t\t\t\t\t\t\t\t\t4.6.\n\t\tLOOP \t\t\t\t\t\t\t\t4.6.1\n\t\t\tIl costrutto @loop (\"ciclo\") è la forma più semplice di ciclo disponibile in Rust. Usando la parola-chiave loop, Rust fornisce un modo di ciclare indefinitamente finché si raggiunge qualche istruzione di terminazione. Il @ciclo @infinito di Rust è fatto così:\n\t\t\t\t//Loop è il costrutto adatto per i cicli infinti\n\t\t\t\tloop {\n\t\t\t\t    println!(\"Cicla per sempre!\");\n\t\t\t\t}\n\n\t\tWHILE\t\t\t\t\t\t\t\t4.6.2\n\t\t\tRust ha anche un @ciclo @while (\"fintanto che\"). È fatto così:\n\n\t\t\t\tlet mut x = 5; // mut x: i32\n\t\t\t\tlet mut fatto = false; // mut fatto: bool\n\n\t\t\t\twhile !fatto {\n\t\t\t\t    x += x - 3;\n\n\t\t\t\t    println!(\"{}\", x);\n\n\t\t\t\t    if x % 5 == 0 {\n\t\t\t\t        fatto = true;\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t\tI cicli while sono la scelta appropriata quando non si è sicuri di quante volte si dovrà ciclare.\n\n\t\t\tSe serve un ciclo infinito, si può essere tentati di scrivere:\n\n\t\t\t\twhile true {Run\n\t\t\t\tTuttavia, il costrutto loop è molto più adatto per gestire questo caso:\n\n\t\t\t\tloop {\n\n\n\t\t\tL'analisi del flusso di costrutto di Rust tratta questo costrutto diversamente da un while true, dato che sappiamo che ciclerà per sempre. In generale, più informazione possiamo dare al compilatore, meglio può fare con la sicurezza e la generazione del codice, e perciò si dovrebbe sempre preferire loop quando si intende ciclare indefinitamente.\n\n\t\tFOR \t\t\t\t\t\t\t\t4.6.3\n\t\t\tIl ciclo for viene usato per ciclare un particolare numero di volte. Però i cicli for di Rust funzionano un po' diversamente dagli altri linguaggi di sistema. Il ciclo for di Rust non somiglia al ciclo for del linguaggio C:\n\t\t\t\t//ciclo for in c\n\t\t\t\tfor (x = 0; x < 10; x++) {\n\t\t\t\t\t    printf( \"%d\\n\", x );\n\t\t\t\t\t}\n\n\t\t\tInvece, è fatto così:\n\t\t\t\t//@ciclo@for_(in rut con 0..10 con posizioni 0 fino a 9 l'ultimo escluso)\n\t\t\t\t\n\t\t\t\tfor x in 0..10 {\n\t\t\t\t    println!(\"{}\", x); // x: i32\n\t\t\t\t}\n\n\t\t\t\to, in termini più astratti,\n\n\t\t\t\t\t\tfor var in expression {\n\t\t\t\t\t\t    code\n\t\t\t\t\t\t}\n\t\t\t\tL'espressione è un elemento che può essere convertito in un [iteratore] usando IntoIterator. L'iteratore rende una serie di elementi. Ogni elemento è un'iterazione del ciclo. Tale valore viene poi associato al nome var, che è valido solo nel corpo del ciclo. Una volta che il corpo è finito, il prossimo valore viene preso dall'iteratore, e si esegue un'altra iterazione. Quando non ci sono più valori, il ciclo for è finito.\n\n\t\t\tPOSIZIONI INIZIO E FINE: \n\t\t\t\tNel nostro esempio, 0..10 è un'espressione che prende una posizione di inizio e una di fine, e dà un iteratore su quei valori. Tuttavia, il limite superiore è escluso, così che questo ciclo stamperà i numeri da 0 a 9, e non il 10.\n\n\t\t\t\tRust non ha il ciclo for in \"stile C\" di proposito. Controllare manualmente ogni elemento del ciclo è complicato e soggetto a errori, anche per sviluppatori esperti nel linguaggio C.\n\n\n\t\t\tEnumerazione\n\t\t\t\t\t@for@controllo@ciclo_(per tener traccia dei @cicli usare @enumerate)\n\t\t\t\tQuando c'è bisogno di tener traccia di quante volte si ha già ciclato, si può usare la funzione .enumerate().\n\n\t\t\t\tfor (i, j) in (5..10).enumerate() { //for con enumerate per contare i cicli\n\t\t\t\t\t    println!(\"i = {} e j = {}\", i, j);\n\t\t\t\t\t}\n\t\t\t\t\tEmette:\n\n\t\t\t\t\ti = 0 e j = 5\n\t\t\t\t\ti = 1 e j = 6\n\t\t\t\t\ti = 2 e j = 7\n\t\t\t\t\ti = 3 e j = 8\n\t\t\t\t\ti = 4 e j = 9\n\t\t\t\t\tIn questo caso si devono aggiungere le parentesi intorno al range.\n\n\t\t\tSugli @iteratori:\n\n\n\t\t\t\t//for su due linee di una stringa\n\t\t\t\tlet linee = \"ciao\\nmondo\".lines();\n\n\t\t\t\t\tfor (numerolinea, linea) in linee.enumerate() {\n\t\t\t\t\t    println!(\"{}: {}\", numerolinea, linea);\n\t\t\t\t\t}\n\t\t\t\t\tEmette:\n\n\t\t\t\t\t0: ciao\n\t\t\t\t\t1: mondo\n\n\t\t\tTerminare precocemente l'iterazione\n\t\t\t\t\tDiamo un'occhiata a quel ciclo while di prima:\n\n\t\t\t\t\t\tlet mut x = 5;\n\t\t\t\t\t\tlet mut fatto = false;\n\n\t\t\t\t\t\twhile !fatto {\n\t\t\t\t\t\t    x += x - 3;\n\n\t\t\t\t\t\t    println!(\"{}\", x);\n\n\t\t\t\t\t\t    if x % 5 == 0 {\n\t\t\t\t\t\t        fatto = true;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t}\n\n\t\t\t\t\tAbbiamo dovuto tenere apposta una variabile booleana, fatto, per sapere quando dovremmo uscire dal ciclo. Rust ha due parole-chiave per aiutarci a modificare le iterazioni: break (\"interrompi\") e continue (\"continua\").\n\n\n\t\t\t\t\tIn questo caso, possiamo scrivere il ciclo in un modo migliore usando break:\n\n\t\t\t\t\t\tlet mut x = 5;\n\n\t\t\t\t\t\tloop {//ciclo @loop@infinito_(con interuzione con break)\n\t\t\t\t\t\t    x += x - 3;\n\n\t\t\t\t\t\t    println!(\"{}\", x);\n\n\t\t\t\t\t\t    if x % 5 == 0 { break; }\n\t\t\t\t\t\t}\n\n\t\t\t\t\tAdesso cicliamo per sempre usando loop e usiamo break per uscire precocemente. Anche eseguire un'istruzione return potrebbe servire a terminare il ciclo precocemente.\n\n\t\t\t\t\tcontinue è simile, ma invece di terminare il ciclo, passa alla prossima iterazione. Questo codice stamperà solamente i numeri dispari:\n\n\t\t\t\t\t\tfor x in 0..10 {\n\t\t\t\t\t\t\t//stampa solo i dispari\n\t\t\t\t\t\t    if x % 2 == 0 { continue; }\n\n\t\t\t\t\t\t    println!(\"{}\", x);\n\t\t\t\t\t\t}\n\n\t\t\tEtichette dei cicli\n\t\t\t\t\t\t\t@etichetta_(per i @cicli@esterni )\n\n\t\t\t\t\tSi potrebbero anche incontrare situazioni in cui ci sono @cicli @annidati si vuole specificare a quale ciclo si riferisce una particolare istruzione @break o @continue. Come nella maggior parte degli altri linguaggi, di default an'istruzione break o continue si applicheranno al ciclo più @interno. Dove si volesse applicare break o continue a uno dei @cicli @esterni, si possono usare delle etichette. Il seguente codice stamperà solamente quando sia x che y sono dispari:\n\n\t\t\t\t\t\t'esterno: for x in 0..10 {\n\t\t\t\t\t\t    'interno: for y in 0..10 {\n\t\t\t\t\t\t        if x % 2 == 0 { continue 'esterno; } // continua al ciclo su x\n\t\t\t\t\t\t        if y % 2 == 0 { continue 'interno; } // continua al ciclo su y\n\t\t\t\t\t\t        println!(\"x: {}, y: {}\", x, y);\n\t\t\t\t\t\t    }\n\n    VETTORI \t\t\t\t\t\t\t\t\t\t\t4.7\n    \tDefinizione\t\t\t\t\t\t\t4.7.1\n    \t\t\t@vettori_(il @vettore è un @array@dinamico ed estensibile con il tipo @Vec<T>)\n\n    \t\tUn ‘vettore’ è un @array @dinamico ossia ‘estendibile’, implementato dal tipo Vec<T> nella libreria standard. Il T significa che si possono avere vettori di ogni tipo (si veda il capitolo su [generici][generic] per avere maggiori informazioni). I VETTORI ALLOCANO SEMPRE I LORO DATI NELLO @HEAP. Possono essere creati con la macro vec!:\n    \t\t\tlet v = vec![1, 2, 3, 4, 5]; // v: Vec<i32> !=macro che usa [] ma anche ()\n\n    \t\t\t(Si noti che diversamente dalla macro println! che abbiamo usato in passato, con la macro vec! usiamo le parentesi quadre []. Rust permette di usare entrambi i tipi di parentesi in entrambe le situazioni, questo uso è solo una convenzione.)\n\n\t\t\tC'è una forma alternativa di vec! per ripetere un valore iniziale:\n\t\t\t\tlet v = vec![0; 10]; // dieci zeri\n\n\t\t\tI vettori immagazzinano il loro contenuto sullo heap come array contigui di T. Ciò significa che devono essere capaci di sapere la dimensione di T in fase di compilazione (cioè, quanti byte servono per memorizzare un T?). La dimensione di alcuni oggetti non si può sapere in fase di compilazione. Per tali oggetti si dovrà immagazzinare un puntatore a quell'oggetto: fortunatamente, il tipo Box funziona perfettamente a questo scopo.\n\n\t\tAccedere agli elementi\t\t\t\t4.7.2\n\t\t\tPer ottenere il valore a un particolare indice nel vettore, si usano le []:\n\t\t\t\tlet v = vec![1, 2, 3, 4, 5];\n\n\t\t\t\tprintln!(\"Il terzo elemento di v è {}\", v[2]);\n\n\t\t\tGli indici contano da 0, e perciò il terzo elemento è v[2].\n\n\t\t\tÈ anche importante notare che si deve indicizzare con il tipo usize:\n\n\t\t\t\tlet v = vec![1, 2, 3, 4, 5];\n\n\t\t\t\tlet i: usize = 0;\t//il vettore si deve indicizzare come tipo usize\n\t\t\t\tlet j: i32 = 0;\t\t\n\n\t\t\t\t// funziona\n\t\t\t\tv[i];\n\n\t\t\t\t// non funziona da errore non puoi indicizzarlo come i32 ma deve essere usize\n\t\t\t\tv[j];\n\n\t\tAccesso fuori dai limiti\t\t\t4.7.3\n\t\t\tSe si prova ad accedere un indice che non esiste:\n\t\t\t\tlet v = vec![1, 2, 3];\n\t\t\t\tprintln!(\"L'elemento 7 è {}\", v[7]);\n\n\t\t\tallora il thread attuale andrà in [panico] con un messaggio come questo:\n\t\t\t\tthread 'main' panicked at 'index out of bounds: the len is 3 but the index is 7'\n\n\n\t\t\tSe si vuole gestire gli errori di accesso fuori dai limiti senza andare in panico, si possono usare metodi come get o get_mut, che restituiscono None quando gli viene dato un indice invalido:\n\n\t\t\t\tlet v = vec![1, 2, 3];\n\t\t\t\t\tmatch v.get(7) {  //gestione fuori indice con il @match\n\t\t\t\t\t    Some(x) => println!(\"Item 7 is {}\", x),\n\t\t\t\t\t    None    => println!(\"Spiacente, questo vettore è troppo corto.\")\n\t\t\t\t\t}\n\t\t\n\t\tIterare \t\t\t\t\t\t\t4.7.4\n\t\t\tUna volta che si ha un vettore, si può iterare sui suoi elementi usando for. Ce ne sono tre versioni:\n\n\t\t\t\tlet mut v = vec![1, 2, 3, 4, 5];\n\n\t\t\t\t\tfor i in &v {\n\t\t\t\t\t    println!(\"Un riferimento a {}\", i);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor i in &mut v {\n\t\t\t\t\t    println!(\"Un riferimento mutabile a {}\", i);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor i in v {\n\t\t\t\t\t    println!(\"Prendi il possesso del vettore e del suo elemento {}\", i);\n\n\t\t    CON RIFERIMENTO & PUOI ITERARE PIU VOLTE IL VETTORE \n\t\t    \tNota: Non si può usare ancora il vettore dopo averlo iterato prendendone il possesso. Invece, si può iterare il vettore più volte se quando lo si itera se ne prende un riferimento. Per esempio, il seguente codice non compila.\n\n\n\t\t    \tlet v = vec![1, 2, 3, 4, 5];\n\n\t\t\t\t\t//I° ITERAZIONE con presa in possesso\n\t\t\t\t\tfor i in v {\n\t\t\t\t\t    println!(\"Prendi possesso del vettore e del suo elemento {}\", i);\n\t\t\t\t\t}\n\n\t\t\t\t\t//ERRORE = la II° iterazione con presa di posse non compila occorre il riferimento &\n\t\t\t\t\tfor i in v {\n\t\t\t\t\t    println!(\"Prendi possesso del vettore e del suo elemento {}\", i);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tMentre il seguente funziona perfettamente:\n\n\t\t\t\t\tlet v = vec![1, 2, 3, 4, 5];\n\n\t\t\t\t\t//I iterazione con riferimento\n\t\t\t\t\tfor i in &v {\n\t\t\t\t\t    println!(\"Questo è un riferimento a {}\", i);\n\t\t\t\t\t}\n\n\t\t\t\t\t//II iterazione con riferimento\n\t\t\t\t\tfor i in &v {\n\t\t\t\t\t    println!(\"Questo è un riferimento a {}\", i);\n\t\t\t\t\t}\n\n\tPOSSESSO \t\t\t\t\t\t\t\t\t\t\t4.8\n\t\tNote\n\t\t\tQuesta è la prima delle tre sezioni che presentano il sistema di possesso di Rust. Questa è una delle caratteristiche più distintive e avvincenti di Rust, con la quale gli sviluppatori Rust dovrebbero diventare familiari. Il possesso è il modo in cui Rust raggiunge il suo maggior obiettivo, la sicurezza di accesso alla memoria. Ci sono alcuni concetti distinti, ognuno descritto in una sezione distinta:\n\n\t\t\til possesso, che è la sezione attuale\n\t\t\ti prestiti, e le caratteristiche a loro associate, i ‘riferimenti’\n\t\t\ti tempi di vita, un avanzato concetto di prestito\n\t\t\tQueste tre sezioni sono correlate, e seguono un ordine. Bisognerà leggerli tutti e tre per capire pienamente il sistema di possesso.\n\n\t\t\n\t\tMeta\t\t\t\t\t\t\t\t4.8.1\n\t\t\tRust ha un'attenzione particolare sulla sicurezza e sulla velocità. Raggiunge questi obiettivi tramite molte ‘ASTRAZIONI A COSTO ZERO’, il che significa che in Rust, le astrazioni costano il meno possibile al fine di farle funzionare. Il sistema di possesso è un esempio primario di astrazione a costo zero. Tutta l'analisi di cui parleremo in questa guida viene fatta in fase di compilazione. Non si paga nessun costo in fase di esecuzione per queste funzionalità.\n\t\t\tIl costo sono i tempi di apprendimento in quanto si combatte con il verificatore di possesso perché il modello mentale del programmatore di come il possesso dovrebbe funzionare non combacia con le regole effettivamente implementate da Rust ma col tempo si migliora.\n\n\n\t\tPossesso\t\t\t\t\t\t\t4.8.2\n\t\t\tI legami di variabili hanno una proprietà in Rust: ‘possiedono’ quello a cui sono legati. Ciò significa che quando un legame esce di ambito, Rust libererà le risorse legate. Per esempio:\n\n\t\t\t\tfn foo() {\n\t\t\t\t    let v = vec![1, 2, 3];  //vettore che viene messo sull'heap gli elementi + nello stack il vettore\n\n\t\t\t\t}\n\n\t\t\tQuando v viene nell'ambito, \n\t\t\t\tviene creato un nuovo vettore sullo STACK, \n\t\t\t\te alloca spazio sullo HEAP per i suoi elementi. \n\t\t\tQuando v esce di ambito alla fine di foo(), Rust ripulirà ogni cosa correlata al vettore, anche la memoria allocata sullo heap. Questo avviene deterministicamente alla fine dell'ambito.\n\n\t\tSemantica di spostamento\t\t\t4.8.3\n\t\t\tPerò qui c'è qualche \n\t\t\t\taltra sottigliezza: \n\t\t\t\t\tRUST ASSICURA CHE CI SIA ESATTAMENTE UN LEGAME A OGNI DATA RISORSA. Per esempio, se abbiamo un vettore, possiamo assegnarlo a un altro legame:\n\n\t\t\t\t\t\tlet v = vec![1, 2, 3];\n\t\t\t\t\t\tlet v2 = v;  //vettore v assegnato a v2 ma v perde il legame\n\t\t\t\t\t\n\t\t\t\t\tMa, se dopo proviamo a usare v, otteniamo un errore:\n\t\t\t\t\tL'errore si presenta così:\n\t\t\t\t\t\tlet v = vec![1, 2, 3];\n\t\t\t\t\t\t\tlet v2 = v;   //il legame v viene assegnato a v2\n\t\t\t\t\t\t\tprintln!(\"v[0] vale: {}\", v[0]);  //ma v perde il legame\n\n\t\t\t\t\t\terror: use of moved value: `v`\n\t\t\t\t\t\tprintln!(\"v[0] vale: {}\", v[0]);\n\n\t\t\tANCHE LA FUNZIONE PERDE IL LEGAME DELL'ARGOMENTO\n\t\t\t\tUna cosa simile accade se definiamo una funzione che prende possesso dell'argomento, e proviamo a usare qualcosa dopo che l'abbiamo passato come argomento:\n\t\t\t\t\t//la funnzione prende il possesso dell'argomento\n\t\t\t\t\tfn prendi(v: Vec<i32>) {\n\n\t\t\t\t\t    // ciò che accade qui dentro non è importante.\n\t\t\t\t\t}\n\n\t\t\t\t\tlet v = vec![1, 2, 3]; //Legame v che viene passato alla funzione \n\t\t\t\t\t\t\t\t\t\t\tprendi\n\t\t\t\t\tprendi(v);  //passo il legame alla funzione\n\n\t\t\t\t\tprintln!(\"v[0] vale: {}\", v[0]); //legame perso con la fine della\n\t\t\t\t\t \t\t\t\t\t\t\t\tfunzione.\n\n\t\t\t\tStesso errore: ‘use of moved value’. Quando si trasferisce il possesso di un oggetto da un legame a un altro, si dice che l'oggetto a cui si fa riferimento è stato ‘spostato’. Qui non ci vuole qualche sorta di annotazione speciale, è il normale comportamento di Rust.\n\n\n\t\tI dettagli\t\t\t\t\t\t\t4.8.4\n\t\t\tDopo lo spostamento dell'oggetto il legame non puo essere piu utilizzato. \n\t\t\tQuando scriviamo del codice come questo:\n\n\t\t\t\tlet x = 10;  //x = oggetto x va nello stack mentre per 10; il riferimento del valore 10 nell'heap\n\n\t\t\tRust alloca sullo stack della memoria per un intero i32, copia i bit che rappresentano il valore 10 alla memoria allocata, e lega il nome della variabile x a questa regione di memoria per poterna riferire in seguito.\n\n\t\t\tAdesso consideriamo il seguente frammento di codice:\n\t\t\t\t//l'oggetto let v = memorizzato nello statck\n\t\t\t\tlet v = vec![1, 2, 3];  // per i valori [1, 2, 3]; vie copiato il \n\t\t\t\t\t\t\t\t\t\t   riferimento nell'heap al primo numero\n\t\t\t\tlet mut v2 = v;\n\n\t\t\tMa in aggiunta a ciò, alloca anche della memoria sullo heap per i dati effettivi ([1, 2, 3]). \n\t\t\tRust copia l'indirizzo di questa allocazione sullo heap al puntatore interno, che fa parte dell'oggetto vettore posto sullo stack (chiamiamolo \"puntatore ai dati\").\n\n\t\t\tVETTORE NELLO STACK - DATI NELL'HEAP = Vale la pena evidenziare (anche al rischio di affermare l'ovvio) che \n\t\t\t\tl'oggetto vettore e i suoi dati \n\t\t\tvivono in regioni di memoria separate, invece di essere un'unica allocazione di memoria contigua (a causa di ragioni che non approfondiremo in questo momento). Queste due parti del vettore (quella sullo stack e quella sullo heap) devono accordarsi l'un l'altra in ogni momento riguardo a cose come la lunghezza, la capacità, ecc.\n\n\t\t\tQuando si sposta v in v2, Rust effettivamente fa una copia bit-a-bit dell'oggetto vettore v nell'allocazione sullo stack rappresentata da v2. Questa copia superficiale non crea una copia dell'allocazione sullo heap contenente i dati effettivi. Il che significa che ci sarebbero due puntatori al contenuto del vettore entrambi che puntano alla stessa allocazione di memoria sullo heap. Se si potesse accedere sia a v che a v2 nello stesso tempo, si violerebbe la garanzia di sicurezza di Rust, introducendo un'accesso concorrente ai dati.\n\n\t\tI tipi Copy\t\t\t\t\t\t\t4.8.5\n\t\t\tI tipi primativi tipo bool, i32 ecc utilizzano copy e quindi quando \n\t\t\tassegni u i32 con \n\t\t\t\tlet v1=1;\n\t\t\t\tlet v2=v1;\n\t\t\t\tprintln!(\"v vale: {}\", v); //i32 non ha puntatori ai dati ma utilizza\n\t\t\t\t\t\t\t\t\t\t\tCopy e quindi si fa una copia integrale dei dati.\n\t\tOltre al possesso\t\t\t\t\t4.8.6\n\t\t\tal posto della restituzione attivo il prestito\n\n\tRIFERIMENTI E PRESTITI \t\t\t\t\t\t\t\t4.9\n\t\n\t\tBorrowing (@PRESTITO)\t\t\t\t4.9.1 \n\t\t\tPrendere in prestito\n\t\t\t\tAlla fine della sezione sul possesso, avevamo una brutta funzione che si presentava così:\n\n\t\t\t\t\tfn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {\n\t\t\t\t\t    // fa' qualcosa con v1 e con v2\n\n\t\t\t\t\t    // restituisci il possesso di v1 e v2, e restituisci anche\n\t\t\t\t\t    // il risultato della nostra funzione\n\t\t\t\t\t    (v1, v2, 42)\n\t\t\t\t\t}\n\n\t\t\t\t\tlet v1 = vec![1, 2, 3];\n\t\t\t\t\tlet v2 = vec![1, 2, 3];\n\t\t\t\t\tlet (v1, v2, risposta) = foo(v1, v2);\n\n\n\t\t\t\tPerò questo non è tipico di Rust, dato che non sfrutta i prestiti. Ecco il primo passo:\n\n\t\t\t\t\t\tfn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {\n\t\t\t\t\t\t    // fa' qualcosa con v1 e con v2\n\n\t\t\t\t\t\t    // restituisci la risposta\n\t\t\t\t\t\t    42\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet v1 = vec![1, 2, 3];\n\t\t\t\t\t\tlet v2 = vec![1, 2, 3];\n\n\t\t\t\t\t\tlet risposta = foo(&v1, &v2);\n\n\t\t\t\tUn esempio più concreto:\n\n\t\t\t\t\tfn main() {\n\t\t\t\t\t\t//vedi il codice qui: @esempio_(@prestito valori)\n\t\t\t\t\t    // Non importa se non si capisce cosa fa `fold`, quello che importa\n\t\t\t\t\t    // qui è che un riferimento immutabile viene preso in prestito.\n\t\t\t\t\t    fn somma_vec(v: &Vec<i32>) -> i32 {\n\t\t\t\t\t        return v.iter().fold(0, |a, &b| a + b);\n\t\t\t\t\t    }\n\t\t\t\t\t    // Prendi in prestito due vettori e sommane gli elementi.\n\t\t\t\t\t    // Questo tipo di prestito non permette che gli oggetti siano mutati.\n\t\t\t\t\t    fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {\n\t\t\t\t\t        // fa' qualcosa con v1 e con v2\n\t\t\t\t\t        let s1 = somma_vec(v1); //s1 e s2 non possono essere mutati\n\t\t\t\t\t        let s2 = somma_vec(v2);\n\t\t\t\t\t        // restituisci la risposta senza modifiche\n\t\t\t\t\t        s1 + s2\n\t\t\t\t\t    }\n\n\t\t\t\t\t    let v1 = vec![1, 2, 3];\n\t\t\t\t\t    let v2 = vec![4, 5, 6];\n\n\t\t\t\t\t    let risposta = foo(&v1, &v2);\n\t\t\t\t\t    println!(\"{}\", risposta);\n\t\t\t\t\t}\n\n\t\t\t\t\tInvece di prendere dei Vec<i32> come argomenti, prendiamo dei riferimenti: &Vec<i32>. \n\t\t\t\t\tE invece di passare v1 e v2 direttamente, passiamo &v1 e &v2. \n\n\t\t\t\t\tIl tipo &T viene chiamato ‘riferimento’, e invece di possedere la risorsa, ne prende in prestito il possesso. \n\n\t\t\t\t\tUn legame che prende in prestito qualche oggetto non dealloca quella risorsa quando esce dall'ambito. Ciò significa che dopo la chiamata a foo(), possiamo usare ancora i nostri legami originali.\n\n\t\t\t\t\tATTENZIONE RIFERIMENTI IMMUTABILI\n\t\t\t\t\t\tI riferimenti sono immutabile, come i legami. Ciò significa che dentro foo(), i due vettori non possono affatto essere modificati:\n\n\t\t\t\t\t\t\tfn foo(v: &Vec<i32>) {\n\t\t\t\t\t\t\t     v.push(5);  //SE MODIFICHI IL VETTORE ERRORE PERCHE IL\n\t\t\t\t\t\t\t     \t\t\t//PRESTITO E' IMMUTABILE\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet v = vec![];\n\n\t\t\t\t\t\t\tfoo(&v);\n\t\t\t\t\t\t\tci darà questo errore:\n\n\t\t\t\t\t\t\terror: cannot borrow immutable borrowed content `*v` as mutable\n\t\t\t\t\t\t\tv.push(5);\n\t\t\t\t\t\t\t^\n\t\t\t\t\t\t\tAggiungere un valore (chiamando push) muterebbe il vettore, e quindi non ci viene permesso.\n\n\t\ti riferimenti &mut \t\t\t\t\t4.9.2\n\t\t\t\t@come@modificare_(la risorsa presa in prestito)\n\t\t\tC'è un altro tipo di riferimenti: &mut T. Un ‘riferimento mutabile’ permette di mutare la risorsa che viene presa in prestito. Per esempio:\n\t\t\t\tlet mut x = 5;    //x legame mut\n\t\t\t\t\t{\n\t\t\t\t\t    let y = &mut x; //y= riferimento mutabile a x perche &mut x\n\t\t\t\t\t    \t\t\t\t//preso in prestito da x e così puo essere incrementato\n\t\t\t\t\t    // *y = asterico prima di y per accesso al riferimento sia  se\n\t\t\t\t\t    //      mutabile o non è mutabile\n\t\t\t\t\t    *y += 1;\t//incrementi perchè marcato con &mut ..\n\t\t\t\t\t}\n\t\t\t\t\tprintln!(\"{}\", x);  //stampa 6\n\n\t\t\tAbbiamo creato y come riferimento mutabile a x, e poi abbiamo incrementato l'oggetto a cui y punta. Si noterà che abbiamo dovuto marcare anche x come mut. Se non l'avessimo fatto, non avremmo potuto prendere in prestito mutabile un valore immutabile.\n\n\t\t\tPERCHE' * = ACCESSO AL RIFERIMENTO MUTABILE O NON MUTABILE\n\t\t\t\tSi noterà anche che abbiamo aggiunto un asterisco (*) prima di y, rendendolo *y. Questo è necessario perché y è un riferimento. SI deve usare un asterisco per accedere al contenuto di un riferimento, che sia mutabile o immutabile.\n\n\t\tle regole\t\t \t\t\t\t\t4.9.2\n\t\t\tEcco le regole per prendere a prestito in Rust:\n\t\t\t\tAMBITO DEL PRESTITO <= A QUELLO DEL POSSESSORE = Primo, ogni prestito deve durare per un ambito non più esteso di quello del possessore.\n\t\t\t\t\t@prestito_(in Rust deve rimanere nell'ambito per cui è valido\n\t\t\t\t\te per fare un prestito occorre &T = prestito non mutabile)\n\t\t\t\t\n\n\t\t\t\tSecondo, si può avere uno o l'altro dei due seguenti generi di prestiti, ma non entrambi allo stesso tempo:\n\t\t\t\t\t\t@riferimenti_@immutabili_o_@mutabili_(per fare un prestito in rust occorre &T e se mutabile &mut T:\n\t\t\t\t\t\t\t @&T= prestito immutabile; \n\t\t\t\t\t\t\t @&mut T =  prestito @mutabile )\n\n\t\t\t\tA) uno o più riferimenti non mutabili (&T) a un oggetto,\n\t\t\t\tB) esattamente un riferimento mutabile (&mut T) a un oggetto.\n\n\t\t\t\tCORSA AI DATI =  C'è una ‘@corsa @ai @dati’ @data@race quando due o più puntatori accedono alla medesima posizione di memoria nello stesso tempo, e per almeno uno di essi tale accesso è in scrittura, e tali accessi non sono sincronizzati.\n\n\t\t\t\tTANTI RIFERIMENTI MUTABILE SOLO UNO MUTABILE ALLA VOLTA = Per quanto riguarda i riferimenti immutabili, se ne possono avere quanti se ne vogliono, dato che nessuno di essi sta scrivendo. Però, dato possiamo avere solamente un riferimenti mutabili per volta, è impossibile avere una corsa ai dati. Questa tecnica consente a RUST IN FASE DI COMPILAZIONE DI PREVENIRE LE CORSE AI DATI: otterremmo degli errori se violiamo le regole.\n\t\t\t\tTenendo questo a mente, consideriamo ancora il nostro esempio.\n\n\t\tPensare secondo gli ambiti\t\t\t4.9.3\n\t\t\t\n\t\t\t//il prestito mutabile valido e parte da x e finisce alla graffa finale,\n\t\t\t// l'ambita parte da --> { .... e finisce con ---> }\n\t\t\tfn main() {\n\t\t\t\t\t'//prestito mutabile parte qui'\n\t\t\t\t    let mut x = 5;\t\t//&mut T = riferimento MUTABILE di x\n\t\t\t\t    let y = &mut x;     //&mut T = faccio il prestito mutabile di x\n\t\t\t\t    \t\t\t\t\t// a y\n\n\t\t\t\t    *y += 1;\t\t\t//prendo il riferimento con *Y = puntatore e lo\n\t\t\t\t    \t\t\t\t\t// incremento\n\t\t\t\t    \t\t\t\t\t//fino qui il prestito è mutabile e x non è piu\n\t\t\t\t    \t\t\t\t\t// possessore\n\n\t\t\t\t    println!(\"{}\", x);\t//da errore il prestito è sempre nell'ambito di y\n\t\t\t\t    \t\t\t\t\t//fino nell'ambito delle graffe e quindi mutabile e non è tornato a x come immutabile\n\n\t\t\t\t} //prestito mutabile valido fino a fine programma \n\n\t\t\t\t\tQuesto codice ci dà questo errore:\n\n\t\t\t\t\terror: cannot borrow `x` as immutable because it is also borrowed as mutable\n\t\t\t\t\tErrore: Impossibile prendere in prestito 'X' come immutabile perché è anche preso in prestito come mutabile\n\n\t\t\t\t\t    println!(\"{}\", x);\n\t\t\t\t\t                   ^\n\n                   Questo perché abbiamo violate le regole: abbiamo un &mut T (mutabile) che punta a x, e così non ci è permesso creare dei &T (immutabili) che puntino al medesimo oggetto. È l'uno o l'altro. L'annotazione suggerisce come pensare a questo problema:\n\n\t\t\t\t\t\tnote: previous borrow ends here\n\t\t\t\t\t\tNota: il prestito precedente termina qui\n\t\t\t\t\t\tfn main() {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t^\n\n\t\t\t\t\tIL PRESTITO MUTABILE VIENE TENUTO PER TUTTO IL PROGRAMMA: In altre parole, il prestito mutabile viene tenuto per tutto il resto del programma. \n\n\t\t\t\t\tCiò che vogliamo è che il prestito mutabile a y finisca, così che la risorsa possa essere restituita al possessore, x. \n\n\t\t\t\t\tPoi x può fornire un prestito immutabile a println!. \n\n\t\t\t\t\tIn Rust, prendere a prestito è legato all'ambito per cui il prestito è valido. E il nostro ambito si presenta così:\n\n\n\t\t\t\t\t\tfn main() {\n\t\t\t\t\t\t    let mut x = 5;     //rende mutabile x\n\n\t\t\t\t\t\t    let y = &mut x;    // -+ qui inizia il prestito mutabile di \n\t\t\t\t\t\t    \t\t\t\t\t\tx \n\t\t\t\t\t\t                       //  |\n\t\t\t\t\t\t    *y += 1;           //  |\n\t\t\t\t\t\t                       //  |\n\t\t\t\t\t\t    println!(\"{}\", x); // -+ - qui prova a prendere a prestito \n\t\t\t\t\t\t    \t\t\t\t\t     immutabile x\n\t\t\t\t\t\t}                      // -+ qui finisce il prestito mutabile di \n\t\t\t\t\t\t\t\t\t\t\t\t\t x\n\t\t\t\t\t\t                       \n\t\t\t\t\t\t Gli ambiti sono in conflitto: non possiamo fare un &x mentre y è nell'ambito.\n\n\n\t\t\t\t\t \tAMBITO CHIAVE DEL PRESTITO\n\t\t\t\t\t\t Perciò quando aggiungiamo le graffe:\n\n\t\t\t\t\t\t\tlet mut x = 5;\n\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t    let y = &mut x; // -+ qui inizia il prestito mutabile\n\t\t\t\t\t\t\t    *y += 1;        //  |\n\t\t\t\t\t\t\t}                   // -+ ... e qui finisce\n\n\t\t\t\t\t\t\tprintln!(\"{}\", x);  // <- qui prova a prendere a prestito immutabile x\n\t\t\t\t\t\t\tNon c'è problema. Il nostro prestito mutabile esce di ambito prima che venga creato quello immutabile. Perciò l'ambito è la chiave per vedere quanto dura un prestito.\n\t\t\t\t\t\t\tvedi --->  @esempio@di_(area scope di y)\n\n\t\tDifetti prevenuti dai prestiti\t\t4.9.4\n\t\t\t\t\tPerché ci sono queste regole restrittive? Beh, come abbiamo detto, queste regole prevengono le corse ai dati. Le corse ai dati che genere di difetti provocano? Ecconi alcuni.\n\n\t\t\tInvalidazione degli iteratori\t\t4.9.4.1\n\t\t\t\tUn esempio è l'‘invalidazione degli iteratori’, che avviene quando si prova a mutare una collezione su cui si sta iterando. Il verificatore dei prestiti di Rust previene che accada:\n\n\t\t\t\t\tlet mut v = vec![1, 2, 3];\n\n\t\t\t\t\t\tfor i in &v {\n\t\t\t\t\t\t    println!(\"{}\", i);\n\t\t\t\t\t\t}\n\n\t\t\t\tQuesto codice stampa i numeri da uno a tre. Mentre iteriamo lungo il vettore, ci vengono dati solamente dei riferimenti agli elementi. E v è esso stesso preso in prestito come immutabile, il che significa che non possiamo cambiarlo mentre stiamo iterando:\n\n\t\t\t\tlet mut v = vec![1, 2, 3];\n\n\t\t\t\t\tfor i in &v {\n\t\t\t\t\t    println!(\"{}\", i);  //fino qui &v = immutabile\n\t\t\t\t\t    v.push(34);\t\t\t//no push perchè È IMMUTABILE\n\t\t\t\t\t}\n\n\n\t\t\t\tcannot borrow `v` as mutable because it is also borrowed as immutable\n    \t\t\tv.push(34);\n\n    \t\t\t non può prendere in prestito 'v' come mutevole perché è anche preso in prestito come immutabile v.push(34);\n\n    \t\t\tnote: previous borrow of `v` occurs here; the immutable borrow prevents\n\t\t\t\t\tsubsequent moves or mutable borrows of `v` until the borrow ends\n\t\t\t\t\tfor i in &v {\n\t\t\t\t\t          ^\n\n\t          \tNota: qui si verifica il precedente prestito di 'V'; Il prestito immutabile impedisce\n\t\t\t\t\tMosse successive o prestiti mutevoli di 'V' fino alla fine del prestito\n\t\t\t\t\tper i in &v {\n\t\t\t\t\t          ^\n\n\t          \tNon possiamo modificare v perché è preso in prestito dal ciclo.\n\n\t\tUso dopo il rilascio\t\t\t\t4.9.5\n\n\t\t\tRIFERIMENTO NON PIU LUNGI DELLA VITA DELL'OGGETTO DI RIFERIMENTO\n\t\t\tI riferimenti non devono vivere più a lungo dell'oggetto a cui fanno riferimento. Rust verificherà gli ambiti dei riferimenti per assicurare che sia così.\n\n\t\t\tSe Rust non verificasse questa proprietà, potremmo accidentalmente usare un oggetto che è diventato invalido. Per esempio:\n\n\n\t\t\t\tlet y: &i32;\n\t\t\t\t\t{\n\t\t\t\t\t    let x = 5;  //creo il legame con x\n\t\t\t\t\t    y = &x;\t\t//faccio un riferimento a x per assegnarlo a Y \n\t\t\t\t\t    \t\t\t//che ha valore finche esiste x\n\t\t\t\t\t}\n\n\t\t\t\t\t//fuori dell'ambito di x e quindi y non è valido\n\t\t\t\t\tprintln!(\"{}\", y);\n\t\t\t\n\n\t\t\tOtteniamo questo errore:\n\n\t\t\t\terror: `x` does not live long enough\n\t\t\t\t    y = &x;\n\t\t\t\t         ^\n\t\t\t\tnote: reference must be valid for the block suffix following statement 0 at\n\t\t\t\t2:16...\n\t\t\t\tlet y: &i32;\n\t\t\t\t{\n\t\t\t\t    let x = 5;\n\t\t\t\t    y = &x;\n\t\t\t\t}\n\n\t\t\t\tnote: ...but borrowed value is only valid for the block suffix following\n\t\t\t\tstatement 0 at 4:18\n\t\t\t\t    let x = 5;\n\t\t\t\t    y = &x;\n\t\t\t\t}\n\n\t\t\tIn altre parole, il valore di y è valido solamente per l'ambito dove x esiste. Non appena x se ne va, diventa invalido fare riferimento ad esso. Come tale, l'errore dice che il prestito ‘non vive abbastanza a lungo’ perché non è valido per la giusta quantità di tempo.\n\n\t\t\tSTESSO ERRORE Y VIVE PIU A LUNGO DI X PERCHE DICHIARATO PRIMA ES.\n\t\t\t\tIl medesimo problema avviene quando il riferimento è dichiarato prima della variabile a cui si riferisce. Questo è devuto al fatto che le risorse entro lo stesso ambito vengono rilasciate nell'ordine inverso di quello con cui sono state acquisite:\n\n\t\t\t\t\tlet y: &i32;  \t//Y creata prima di x \n\t\t\t\t\tlet x = 5;\t\t//x muore prima di y\n\t\t\t\t\ty = &x;         \n\n\t\t\t\t\tprintln!(\"{}\", y); //da errore su y perche x è cessata prima e \n\t\t\t\t\t\t\t\t\t\tquindi viene usata il legame di x quando è già stata rilasciata e non esiste piu mentre Y vive piu a lungo\n\n\t\t\t\tOtteniamo questo errore:\n\n\t\t\t\t\terror: `x` does not live long enough\n\t\t\t\t\ty = &x;\n\t\t\t\t\tErrore: 'X' non vive abbastanza a lungo\n\t\t\t\t\ty = &x;\n\n\n\t\t\t\tNell'esempio qui sopra, y è dichiarato prima di x, il che comporta che y vive (leggermente) più a lungo di x, il che non è consentito.\n\n \tTEMPO DI VITA\t\t\t\t\t\t\t\t\t\t4.10.\n \t\tNote\n \t\t\tQuesta è l'ultima delle tre sezioni che presentano il sistema di possesso di Rust. Qui si assume che siano già state lette le altre due:\n\n\t\t\t\tIl possesso, il concetto chiave\n\t\t\t\tI prestiti, e le loro caratteristiche associate, i ‘riferimenti’\n \t\tI tempi di vita\t\t\t\t\t4.10.1\n \t\t\t\t@lifetime_(@tempo@di@vita il sistema di possesso di Rust che imposta il\n \t\t\t\t\tmomento in cui deve essere rilasciata la risorsa)\n\n\n\t \t\tPrestare un riferimento a una risorsa posseduta da qualcun altro può essere complicato. Per esempio, immaginiamo questa sequenza di operazioni:\n\n\t \t\t\t1 Acquisisco un riferimento a una risorsa di qualche tipo.\n\t\t\t\t2 Ti presto un riferimento a tale risorsa.\n\t\t\t\t3 Decido di aver finito di lavorare con quella risorsa, e quindi la\n\t\t\t\t  rilascio, mentre tu hai ancora il tuo riferimento a tale risorsa.\n\t\t\t\t4 Tu decidi di usare quella risorsa.\n\n\t\t\t\t\t\t@puntatore@penzolante_(un riferimento ad un risorsa non valida)\n\t\t\tAhi, ahi! Il tuo riferimento sta puntando a una risorsa non più valida. Questo difetto si chiama ‘puntatore penzolante‘ o ‘utilizzo dopo il rilascio’.\n\n\t\t\t\t\t\t@life@time_(tempo di vita del riferimento fino al rilascio della risorsa.)\n\t\t\tPer correggerlo, dobbiamo assicurarci che il passo 4 non avvenga mai dopo il passo 3. Il sistema di possesso in Rust lo fa tramite un concetto chiamato \"tempo di vita\" [\"lifetime\"], che descrive l'ambito in cui un riferimento è valido. Nel nostro caso, o decidiamo che il tempo di vita vale solamente fino al passo 3, e in tal caso il passo 4 darà errore di compilazione, o decidiamo che il tempo di vita vale fino al passo 4, e in tal caso la risorsa dovrà essere rilasciata al passo 5.\n\n\t\t\tRIFERIMENTI IMPLICITI O ESPLICITI\n\t\t\tQuando abbiamo una funzione che prende un argomento per riferimento, possiamo essere impliciti o espliciti riguardo al tempo di vita di tale riferimento:\n\t\t\t\t\n\t\t\t\t// implicito\n\t\t\t\t\tfn foo(x: &i32) {\n\t\t\t\t\t}\n\n\t\t\t\t\t// esplicito : bar ha un solo tempo di vita <'a>\n\t\t\t\t\tfn bar<'a>(x: &'a i32) {  //\n\t\t\t\t\t}\n\t\t\tL'a si legge ‘il tempo di vita a’.\n\t\t\tTecnicamente, ogni riferimento ha qualche tempo di vita associato ad esso, ma il compilatore consente di eliderlo (cioè ometterlo, si veda la sezione [\"@Elisione del tempo di vita\"] [elisione del tempo di vita] più avanti) nei casi più tipici.\n\t\t\terò, prima di arrivarci, scomponiamo l'esempio esplicito:\n\n\t\t\t\tfn bar<'a>(...) = angolari  <> dopo il nome della funzione per dichiarare i tempi di \n\t\t\t\t\t\t\t\t\t\t\t   vita personali\n\n\n\t\t\tPrecedentemente abbiamo parlato un po' della sintassi delle funzioni, ma non abbiamo discusso dei <> dopo il nome della funzione. Una funzione può avere dei ‘parametri generici’ fra le <>, dei quali i tempi di vita sono un tipo. Discuteremo altri tipi di generici più avanti nel libro, ma per adesso, focalizziamoci sull'aspetto dei tempi di vita.\n\n\t\t\tUsiamo le <> per dichiarare i nostri tempi di vita. Questo dice che bar ha un solo tempo di vita, 'a. Se avessimo dei parametri riferimento, si presenterebbe così:\n\n\t\t\t\tfn bar<'a, 'b>(...)\n\n\t\t\tPoi nel nostro elenco di argomenti, usiamo i tempi di vita che abbiamo nominato:\n\n\t\t\t\t...(x: &'a i32)  \n\n\t\t\tSe avessimo voluto un riferimento &mut, avremmo scritto:\n\n\t\t\t\t...(x: &'a mut i32)  //riferimento mutabile i  32 con tempo di vita di a\n\n\t\t\tConfrontando &mut i32 con &'a mut i32, si nota che \n\t\t\t\tl'unica differenza è che il tempo di vita 'a si è intrufolato fra il & il mut i32. \n\n\t\t\tLa clausola &mut i32 va letta come \n\t\t\t\t‘un riferimento mutabile a un i32’, mentre \n\t\t\t\tla clausola &'a mut i32 va letta come ‘un riferimento mutabile a un i32 con tempo di vita 'a’.\n \t\tNelle struct\t\t\t\t\t4.10.2\n \t\t\t\tNote\n \t\t\t\t\tcreo un programma per l'esempio tempo_di_vita_struct vedi\n \t\t\t\t\tesempio:\n \t\t\t\t\t \t@esempio@tempo_(di vita foo @NELLA @STRUCT o @struttura)\n\n \t\t\tC'è bisogno dei tempi di vita espliciti anche quando si lavora come le struct che contengono riferimenti:\n\n\n \t\t\t\t//TEMPI DI VITA ESPLICITI = riferimento a Foo con tempo di vita = a i32 che lo contiene e non superiore\n \t\t\t\tstruct Foo<'a> {  //Foo<'a> = strutture con tempi di vita espliciti\n\t\t\t\t\t    x: &'a i32,\n\t\t\t\t\t}\n\n\t\t\t\t\tfn main() {\n\t\t\t\t\t    let y = &5; // questo è lo stesso che `let _y = 5; let y = &_y;`\n\t\t\t\t\t    let f = Foo { x: y };   //chiami foo e passi x:Y ossia il valore di Y a x\n\t\t\t\t\t    //f\n\t\t\t\t\t    println!(\"{}\", f.x);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tCome si vede, anche le struct possono avere tempi di vita. In modo simile alle funzioni, truct Foo<'a> { = dichiara un tempo di vita, e x: &'a i32, lo usa. \n\n\t\t\t\t\tAllora perché qui ci serve un tempo di vita? Ci serve per assicurare che ogni : riferimento a un Foo non possa sopravvivere al \n\t\t\t\t\triferimento a un i32 che contiene.\n\t\tI blocchi impl\t\t\t\t\t4.10.3\n \t\t\tImplementiamo un metodo su Foo:\n \t\t\t\t\t@tempi@di@vita_(nella struct e nella implementazione che deve esser ripetuto \n \t\t\t\t\t\tdue volte il tempo di vita)\n\n \t\t\t//01 la struttura Foo con tempo di vita\n \t\t\tstruct Foo<'a> {\n    \t\t\tx: &'a i32,\n\t\t\t\t}\n\t\t\t//02 implementi foo ma con doppia ripetizione del tempo di vita,\n\t\t\t//impl<'a> \t= definisce il tempo di vita\n\t\t\t//Foo<'a> \t= utilizza il tempo di vita\n\t\t\t\timpl<'a> Foo<'a> {\n\t\t\t\t    fn x(&self) -> &'a i32 { self.x }\n\t\t\t\t}\n\n\t\t\t\tfn main() {\n\t\t\t\t    let y = &5; // questo è lo stesso che `let _y = 5; let y = &_y;`\n\t\t\t\t    let f = Foo { x: y };\n\t\t\t\t    println!(\"x is: {}\", f.x());\n\t\t\t\t}\n\n\n\t\t\tCome si vede, dobbiamo dichiarare un tempo di vita per Foo nella riga di impl. 'a viene ripetuto, come per le funzioni: impl<'a> definisce un tempo di vita 'a, e Foo<'a> lo usa.\n\t\tTempi di vita multipli\t\t\t4.10.4\n\t \t\tSe si hanno riferimenti multipli, si può usare lo stesso tempo di vita più volte:\n\n\t \t\t\t//tempi di vita uguali tra x e y\n\t \t\t\tfn x_o_y<'a>(x: &'a str, \n\t \t\t\t\t\t\t y: &'a str) -> &'a str {\n\n\t\t \tQuesto dice che sia x che y sono vivi per lo stesso ambito, e che anche il valore reso è vivo per lo stesso ambito. \n\n\t\t \tSe si voless che x e y avessero tempi di vita diversi, si possono usare più parametri di tempo di vita:\n\n\t\t \t\t//TEMPO DI VITA DIVERSI ma con con valore reso uguale a quello di x\n\t\t \t\tfn x_o_y<'a, 'b>(x: &'a str,  //ritorna il risultato con il tempo di vita di x   \n\t\t \t\t                 y: &'b str) -> &'a str { ...\n\n\t     \tIn questo esempio, x e y hanno diversi ambiti validi, ma il valore reso ha lo stesso tempo di vita di x.\n \t\tPensare agli ambiti\t\t\t\t4.10.5\n \t\t\tUn modo di pensare ai tempi di vita è visualizzare l'ambito per cui un riferimento rimane valido. Per esempio:\n\t\t\t\t \tfn main() {\n\t\t\t\t    let y = &5;    \t\t\t// -+ y entra nell'ambito\n\t\t\t\t                   \t\t\t//  |\n\t\t\t\t    // scrivi coidice       //  |\n\t\t\t\t                            //  |\n\t\t\t\t}                  \t\t\t// -+ y esce dall'ambito (RAPPRESENTATAO DALLA GRAFFE)\n\t\t\t\n\t\t\tAggiungendo il nostro Foo:\n\n\t\t\t\t//aggiunto il Foo con ambito di vita della x\n\t\t\t\tstruct Foo<'a> {\n\t\t\t\t    x: &'a i32,\n\t\t\t\t}\n\n\t\t\t\tfn main() {\n\t\t\t\t    let y = &5;           // -+ y entra nell'ambito y=riferimento a 5\n\t\t\t\t    let f = Foo { x: y }; // -+ f entra nell'ambito - chiama foo e gli passa y\n\t\t\t\t    // roba               //  |\n\t\t\t\t                          //  |\n\t\t\t\t}                         // -+ prima f e poi y escono dall'ambito\n\t\t\t\t\t\t\t\t\t\t  //alla fine delle graffe sia y che f ossia x hanno lo stesso\n\t\t\t\t\t\t\t\t\t\t  //tempo di vita e quindi vengono distrutte in modo uguale\t\n\n\n\t\t\t   Il nostro f vive entro l'ambito di y, perciò tutto funziona. E non fosse così? Questo codice non funziona:\n\n\t\t\t\t\tstruct Foo<'a> {\n\t\t\t\t\t    x: &'a i32,\n\t\t\t\t\t}\n\n\t\t\t\t\tfn main() {\n\t\t\t\t\t    let x;                    // -+ x entra nell'ambito ma fuori le graffe\n\t\t\t\t\t                              //  |\n\t\t\t\t\t    {                         //  |\n\t\t\t\t\t        let y = &5;           // ---+ y entra nell'ambito piu piccolo le graffe interne\n\t\t\t\t\t        let f = Foo { x: y }; // ---+ f entra nell'ambito\n\t\t\t\t\t        x = &f.x;             //  | | errore qui\n\t\t\t\t\t    }                         // ---+ prima f e poi y escono dall'ambito\n\t\t\t\t\t                              //  |\n\t\t\t\t\t    println!(\"{}\", x);        //  |  quindi x non ha piu riferimento perche distrutta la x insieme a y\n\t\t\t\t\t}                             // -+ x esce dall'ambito\n\n\n\t\t\t\tCome si vede, gli ambiti di f e y sono più piccoli dell'ambito di x. \n\t\t\t\tMa quando facciamo x = &f.x, rendiamo x un riferimento a qualcosa che sta per uscire dal suo ambito.\n\n\t\t\t\tI tempi di vita con nome sono un modo di dare un nome a questi ambiti. \n\t\t\t\tDare un nome a qualcosa è il primo passo verso l'essere capaci di parlarne.\n\n \t\tstatic\t\t\t\t\t\t\t4.10.5\n \t\t\t@static_(tempo di vita dell'intero programma)\n\t \t\tIl tempo di vita chiamato ‘static’ è un tempo di vita speciale. Segnala che qualcosa ha il tempo di vita dell'intero programma. La maggior parte dei programmatori Rust si imbattono per la prima volta in 'static quando trattano le stringhe:\n\t \t\t\t\n\t \t\t\t//stringa static che viene salvata alla fine del file binario e vale per tutto il programma\n\t \t\t\tlet x: &'static str = \"Ciao, mondo.\";\n\n\t\t\tLe lettere della stringa sono di tipo &'static str perché il riferimento è sempre vivo: vengono depositati nel segmento dati del file binario finale. Un altro esempio sono i globali:\n\n\t\t\t\t//variabile globale, i32 inserita nel segmento dati del file binario\n\t\t\t\tstatic FOO: i32 = 5;\n\t\t\t\tlet x: &'static i32 = &FOO;\n\n\t\t\tQuesto aggiunge un i32 al segmento dati del file binario, e x è un riferimento a esso.\n\n \t\tElisione del tempo di vita\t\t4.10.6\n\n \t\t\tINFERENZA LOCALE SOLO NEI CORPI DELLE FUNZIONI - NESSUNA INFERENZA NELLE FIRME -\n \t\t\tRust supporta una potente inferenza di tipo locale nei corpi delle funzioni ma non nelle firme dei loro elementi. È vietato consentire di ragionare sui tipi a seconda della sola firma degli elementi. \n \t\t\tPerò, per ragioni di comodità, un algoritmo di INFERENZA SECONDARIA molto ristretto chiamato “ELISIONE DEL TEMPO DI VITA” si applica quando si giudicano i tempi di vita. \n\n \t\t\tL'elisione dei tempi di vita viene considerata solamente per inferire i parametri del tempo di vita usando tre regole facilmente memorizzabili e non ambigue. \n \t\t\t\n \t\t\t\tCiò significa che \n \t\t\t\t\tl'elisione del tempo di vita agisce da abbreviazione per scrivere una firma di un elemento, \n\t\t\t\tmentre non nasconde i tipi effettivamente coinvolti, come avverrebbe se fosse applicata una una completa inferenza locale. \t\n\t\t\n\t\t\tELISIONE DI TEMPO DI VITA DI IMPUT E DI OUTPUT\n\t\t\tQuando si parla dell'elisione del tempo di vita, usiamo i termini tempo di vita di input e tempo di vita di output. Un tempo di vita di input è un tempo di vita associato a un argomento di una funzione, mentre un tempo di vita di output è un tempo di vita associato a un valore reso da una funzione. Per esempio, questa funzione ha un tempo di vita di input:\n\t\t\t\t//TEMPO DI VITA DI INPUT\n\t\t\t\tfn foo<'a>(bar: &'a str)\n\n\t\t\t\tQuest'altra ha un tempo di vita di output:\n\n\t\t\t\t//attenzione () = non c'è parametro\n\t\t\t\tfn foo<'a>() -> &'a str   //restituzione del'outuput\n\n\n\t\t\t\tE questa ha un tempo di vita in entrambe le posizioni:\n\n\t\t\t\tfn foo<'a>(bar: &'a str) -> &'a str  //tempo di vita di imput e di output\n\n\n\t\t\t\tEcco le tre regole: (?? non chiare??)\n\n\t\t\t\t\tOgni tempo di vita eliso tra gli argomenti di una funzione diventa un un distinto parametro tempo di vita.\n\n\t\t\t\t\tSe c'è esattamente un tempo di vita di input, eliso o no, quel tempo di vita è assegnato a tutti i tempi di vita elisi nei valori resi di quella funzione.\n\n\t\t\t\t\tSe ci sono più tempo di vita di input, ma uno di essi è \n\t\t\t\t\t\t&self o \n\t\t\t\t\t\t&mut self, \n\t\t\t\t\til tempo di vita di self viene assegnato a tutti i tempi di vita di output elisi.\n\n\t\t\t\t\tAltrimenti, è un errore elidere un tempo di vita di output.\n\n \t\tEsempi\t\t\t\t\t\t\t4.10.7\n\t \t\tEcco alcuni esempi di funzioni con tempi di vita elisi. Abbiamo accoppiato ogni esempio di un tempo di vita eliso con la sua forma espansa.\n\t \t\t\tfn stampa(s: &str); // eliso\n\t\t\t\tfn stampa<'a>(s: &'a str); // espanso\n\n\t\t\t\t\t//lvl: u32 = non ha tempo di vita\n\t\t\t\tfn debug(lvl: u32, s: &str); // eliso\n\t\t\t\tfn debug<'a>(lvl: u32, s: &'a str); // espanso\n\n\t\t\tNell'esempio precedente, lvl non ha bisogno di un tempo di vita, perché non è un riferimento (&). \n\n\t\t\tSolamente oggetti riferiti a riferimenti (come uno struct che contiene un riferimento) hanno bisogno di tempi di vita.\n\t\t\t\t\t//@molto@difficili_(non si comprendono ??? @tempi@di@vita @incomprensibili)\n\n\t\t\t\t\tfn substr(s: &str, until: u32) -> &str; // eliso\n\t\t\t\t\tfn substr<'a>(s: &'a str, until: u32) -> &'a str; // espanso\n\n\t\t\t\t\tfn get_str() -> &str; // ILLEGALE, nessun input\n\n\t\t\t\t\tfn frob(s: &str, t: &str) -> &str; // ILLEGALE, due input\n\t\t\t\t\t// espanso: il tempo di vita di output è ambiguo\n\t\t\t\t\tfn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str;\n\n\t\t\t\t\tfn get_mut(&mut self) -> &mut T; // eliso\n\t\t\t\t\tfn get_mut<'a>(&'a mut self) -> &'a mut T; // espanso\n\n\t\t\t\t\tfn argomenti<T: ToCStr>(&mut self, args: &[T]) -> &mut Command; // eliso\n\t\t\t\t\tfn argomenti<'a, 'b, T: ToCStr>(&'a mut self, args: &'b [T])\n\t\t\t\t\t-> &'a mut Command; // espanso\n\n\t\t\t\t\tfn new(buf: &mut [u8]) -> BufWriter; // eliso\n\t\t\t\t\tfn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>; // espanso\n\n IMMUTABILITA\t\t\t\t\t\t\t\t\t\t\t4.11.\n \tNON DI DEFAULT\n\t \tLa mutabilità, ossia la capacità di cambiare qualcosa, funziona in Rust un po' diversamente che in altri linguaggi. Il primo aspetto della mutabilità in Rust è il fatto di non esserci per default:\n\t \t\tlet x = 5;\n\t\t\tx = 6; // errore!\n\t\tSi può introdurre la mutabilità con la parola-chiave mut:\n\t\t\tlet mut x = 5;\n\t\t\tx = 6; // non c'è problema!\n\n\t\t\tQuesto è un legame di variabile mutabile. Quando un legame è mutabile, significa che si può cambiare ciò a cui quel legame punta. Perciò nell'esempio sopra, non è tanto che il valore alla posizione x cambia, quanto che il legame passa dal puntare un i32 al puntarne un altro.\n\n\t\t\t\n\t\t\tSi può anche creare un riferimento ad esso, usando &x, ma se si vuole usare il riferimento per cambiarlo, ci vorrà un riferimento mutabile:\n\t\t\t\tlet mut x = 5;\n\t\t\t\tlet y = &mut x;  //y legame immutabile di default che non si lega ad altro valore ma\n\t\t\t\t\t\t\t\t //viene utilizzato y per legare x (o riferimento a x mutevole)\n\n\t\t\t\ty è un legame immutabile a un riferimento mutabile, il che significa che non si può legare 'y' a qualcos'altro (y = &mut z), ma y può essere usato per legare x a qualcos'altro (*y = 5). Una distinzione sottile.\n\n\t\tNaturalmente, se servono entrambi:\n\t\t\tlet mut x = 5;\n\t\t\tlet mut y = &mut x;\n\n\t\t\tAdesso y può essere legato a un altro valore, e inoltre il valore che sta referenziando può essere cambiato.\n\n\t\tÈ importante notare che mut fa parte di un pattern, e perciò si possono fare cose come questa:\n\n\t\t\tlet (mut x, y) = (5, 6);\n\n\t\t\tfn foo(mut x: i32) {\n\n\t\tSi noti che qui la x è mutabile, mentre la y non lo è.\n\n \t\n \tMutabilità interiore contro mutabilità esteriore\t\t\t\t\t\t4.11.1 \t\n \t\tMUTABILITA ESTERIORE\n\t \t\tPerò, quando diciamo che qualcosa è ‘immutabile’ in Rust, non intendiamo che è impossibile cambiarla: ci stiamo riferendo alla sua ‘immutabilità esteriore’. Si consideri, per esempio, \n\t \t\tArc<T>:\n\t \t\t\tuse std::sync::Arc;  //OGGETTO Arc<T>\n\t\t\t\tlet x = Arc::new(5); //X legame immutabile\n\t\t\t\tlet y = x.clone();\n\n\t\t\tQuando chiamiamo clone(), l'oggetto di tipo Arc<T> deve aggiornare il conteggio dei riferimenti. Però qui non abbiamo usato nessun mut, x è un legame immutabile, e non abbiamo preso il valore &mut 5 né altri valori. E allora?\n\n\t\t\tPer capirlo, dobbiamo tornare al nucleo della filosofia guida di Rust, che è la sicurezza di memoria, e al meccanismo col quale Rust la garantisce, che è il sistema di [possesso][possesso], e più specificamente, il [prestito][prestito]:\n\n\t\t\t\tSi possono avere l'uno o l'altro di questi due tipi di prestiti, ma non entrambi allo stesso tempo:\n\n\t\t\t\t\tuno o più riferimenti immutabili (&T) a una risorsa,\n\t\t\t\t\tesattamente un riferimento mutabile (&mut T).\n\n\t\t\tPerciò, questa è la vera definizione di ‘immutabilità’: è sicuro che ci siano due puntatori a questo oggetto? Nel caso di Arc<T>, sì: la mutazione è contenuta interamente dentro la struttura stessa. Non si presenta all'utente. Per questa ragione, passa un &T a clone(). Se gli avesse passato un &mut T, però, sarebbe un errore.\n\n\t\tMUTABILITA INTERIORE\n\t\t\tAltri tipi, come quelli nel modulo std::cell, sono nella situazione opposta: mutabilità interiore. Per esempio:\n\t\t\t\tuse std::cell::RefCell;\n\n\t\t\t\tlet x = RefCell::new(42);  //RefCel pasa dei riferimenti &mut\n\n\t\t\t\tlet y = x.borrow_mut();    //lo passa al suo metodo borrow_mut\n\n\n\t\t\tRefCell passa dei riferimenti &mut a ciò che c'è al suo interno usando il metodo borrow_mut(). Non è pericoloso? Che succede se facciamo:\n\n\t\t\t\tuse std::cell::RefCell;\n\n\t\t\t\tlet x = RefCell::new(42);\n\n\t\t\t\tlet y = x.borrow_mut();\n\t\t\t\tlet z = x.borrow_mut();\n\n\t\t\tDi fatto questo andrà in panico, in fase di esecuzione. Questo è quello che fa RefCell: forza le regole di prestito di Rust in fase di esecuzione, e va in panic! se sono violate. Questo ci consente di aggirare un altro aspetto delle regole di mutabilità di Rust. Prima parliamone.\n\n\n\tMutabilità interiore contro mutabilità esteriore\t\t\t\t\t\t4.11.2\n\tMutabilità a livello di campo\t\t\t\t\t\t\t\t\t\t\t4.11.3\n\t\tLa mutabilità è una proprietà o di un prestito (&mut) o di un legame (let mut). Ciò significa che, per esempio, non si può avere una struct con alcuni campi mutabili e altri immutabili:\n\n\t\tstruct Punto {\n\t\t    x: i32,\t\t\t//questo non è mutabile \n\t\t    mut y: i32, // non si può  -- solo questo è mutabile --\n\t\t}\n\n\n\t\tLa mutabilità di una struct sta nel suo legame:\n\n\t\t\tstruct Punto {\n\t\t\t    x: i32,\n\t\t\t    y: i32,\n\t\t\t}\n\t\t\t\n\t\t\tlet mut a = Punto { x: 5, y: 6 };\n\n\t\t\ta.x = 10;   //immutabile\n\n\t\t\tlet b = Punto { x: 5, y: 6};\n\n\t\t\tb.x = 10; // errore: non si può assegnare al campo immutabile `b.x`\n\n\n\t\tPerò, usando Cell<T>, si può emulare la mutabilità a livello di campo:\n\n\n\t\t\t\tuse std::cell::Cell;\n\n\t\t\t\tstruct Punto {\n\t\t\t\t    x: i32,\n\t\t\t\t    y: Cell<i32>,\n\t\t\t\t}\n\n\t\t\t\tlet punto = Punto { x: 5, y: Cell::new(6) };\n\n\t\t\t\tpunto.y.set(7);\n\n\t\t\t\tprintln!(\"y: {:?}\", punto.y);\n\t\t\t\tQuesto stamperà y: Cell { value: 7 }. Abbiamo aggiornato y con successo.\n\n STRUTTURE \t\t\t\t\t\t\t\t\t\t\t\t4.12.\n \t\tCOMBINA DATI COMPLESSI IN UN SINGOLO DATO\n\t\t \tLe struct sono un modo di creare tipi di dati più complessi. Per esempio, se stessimo facendo calcoli che coinvolgono coordinate nello spazio 2D, cioè nel piano cartesiano ci servirebbero sia un valore x che un valore y:\n\t\t \t\tlet origine_x = 0;\n\t\t\t\tlet origine_y = 0;\n\t\t\tUna struct ci permette di combinare questi due oggetti in UN SINGOLO TIPO DI DATI UNIFICATO, i cui campi sono etichettati x e y:\n\n\t\t\t\t\tstruct Punto { //STRUTTURA CHE COMBINA 2 DATI IN UN SINGOLO TIPO Punto\n\t\t\t\t\t    x: i32,\n\t\t\t\t\t    y: i32,\n\t\t\t\t\t}\n\n\n\t\t\t\t\tfn main() {\n\t\t\t\t\t    let origine = Punto { x: 0, y: 0 }; // origine: Punto\n\n\t\t\t\t\t    println!(\"L'origine è in ({}, {})\", origine.x, origine.y);\n\t\t\t\t\t}\n\t\tPAROLA CHIAVE STRUCT\n\t\t\t\t\n\t\t\t\t@struct@convenzione_(la convenzione nel dichiarare la struct è Camel Case o stile @Pascal)\n\n\t\t\tQui ci sono molte cose, analizziamole. Una struct si dichiara con la parola-chiave struct, e poi con un nome. Per convenzione, le struct hanno la MAIUSCOLIZZAZIONE DEL PASCAL: \t\n\t\t\t\tPuntoNelloSpazio, \n\t\t\tnon Punto_Nello_Spazio, né punto_nello_spazio.\n\n\n\t\t\tLET = Possiamo creare un'istanza della nostra struct usando let, come al solito, ma per impostare ogni campo usiamo una sintassi con lo stile chiave: valore. L'ordine non dev'essere il medesimo della dichiarazione originale.\n\n\t\t\tACCESSO AI CAMPI = Infine, siccome i campi hanno un nome, possiamo accedervi tramite la notazione a punto: origine.x\n\n\n\t\t\tVALORI IMMUTABILI DI DEFAULT = I valori nelle struct sono immutabili di default, come gli altri legami in Rust. Si deve usare mut per renderli mutabili:\n\n\t\t\t\t//struttura con con stile pascal\n\t\t\t\tstruct Punto { //valori immutabili  NON SI PUO' USARE MUT nella struttura solo &\n\t\t\t\t\t    x: i32,\n\t\t\t\t\t    y: i32,\n\t\t\t\t\t}\n\n\t\t\t\t\tfn main() {\n\t\t\t\t\t\t//vengono resi mutabili i valori della struct con let mut punto\n\t\t\t\t\t    let mut punto = Punto { x: 0, y: 0 };\n\n\t\t\t\t\t    //accesso ai campi con origine.campo\n\t\t\t\t\t    punto.x = 5;\n\n\t\t\t\t\t    println!(\"Il punto è in ({}, {})\", punto.x, punto.y);\n\t\t\t\t\t}\n\t\t\t\t\t\tQuesto stamperà Il punto è in (5, 0).\n\n\n\t\t\tNO MUTABILITA DEI CAMPI DELLA STRUCT = Rust non supporta la mutabilità dei campi a livello del linguaggio, quindi non si può scrivere qualcosa così:\n\n\t\t\t\t\tstruct Point {\n\t\t\t\t\t    mut x: i32,  //ERRORE non si puo rendere mutabile un campo della struct\n\t\t\t\t\t    y: i32,\n\t\t\t\t\t}\n\n\n\t\t\tMUTABILITA SOLO DEGLI OGGETTI IN MODO TEMPORANEO = La mutabilità è una proprietà del legame, non della struttura stessa. Chi fosse abituato all mutabilità a livello di campo, lo può trovare strano dapprima, ma semplifica parecchio le cose. Consente perfino di rendere temporaneamente mutabili degli oggetti:\n\n\t\t\t\t\t//@Struttura_(@struct con @campi @immutabili di default)\n\t\t\t\t\tstruct Punto {\n\t\t\t\t\t    x: i32,\n\t\t\t\t\t    y: i32,\n\t\t\t\t\t}\n\n\t\t\t\t\tfn main() {\n\t\t\t\t\t\t\n\t\t\t\t\t\t//@struct@mut_(viene reso @mutabile l'oggetto della struttura)\n\t\t\t\t\t    let mut punto = Punto { x: 0, y: 0 };\n\n\t\t\t\t\t    punto.x = 5; //qui assegni perchè è mutabile\n\n\t\t\t\t\t    let punto = punto; // con il nuovo let adesso è immutabile\n\n\t\t\t\t\t    punto.y = 6; // questo provoca un errore non puo' essere modificato\n\t\t\t\t\t}\n\n\t\t\tSTRUTTURA CON PUNTATORI = Però una struttura può contenere dei puntatori &mut, che consentono di applicare qualche tipo di mutazione:\n\n\n\t\t\t\t//STRUTTURA\n\t\t\t\tstruct Punto {\n\t\t\t\t\t    x: i32,\n\t\t\t\t\t    y: i32,\n\t\t\t\t\t}\n\n\t\t\t\t\t//STRUTTURA CON PUNTATORI CON &mut\n\t\t\t\t\tstruct RifPunto<'a> {\n\t\t\t\t\t    x: &'a mut i32,   //puntatori con &mut\n\t\t\t\t\t    y: &'a mut i32,\n\t\t\t\t\t}\n\n\t\t\t\t\tfn main() {\n\t\t\t\t\t    let mut punto = Punto { x: 0, y: 0 };  //assegno a variabile mutabile\n\n\t\t\t\t\t    {\n\t\t\t\t\t        //ASSEGNO a r i riferimenti mutabili di punto.x e punto.y\n\t\t\t\t\t        let r = RifPunto { x: &mut punto.x, y: &mut punto.y };\n\n\t\t\t\t\t        *r.x = 5; //assegno al campo r.x, r.y i valori\n\t\t\t\t\t        *r.y = 6;\n\t\t\t\t\t    }\n\n\t\t\t\n\n\t\t\t\t\t    assert_eq!(5, punto.x);\n\t\t\t\t\t    \n\t\t\t\t\t    \t\t//stampo dopo assert x\n\t\t\t\t\t    \t\tprintln!(\"stampo dopo il codice assert_eq!(5, punto.x) il valore di x che è = {:?}\", punto.x);\n\t\t\t\t\t    assert_eq!(6, punto.y);\n\n\t\t\t\t\t    \t\t//stampo dopo assert y\n\t\t\t\t\t            println!(\"stampo dopo il codice assert_eq!(5, punto.y) il valore di y che è = {:?}\", punto.y);\n\t\t\t\n\t\t\t\t\t}\n\n\tStrutture ennuple\t\t\t\t\t\t\t\t\t4.12.1 \n\t\tIBRIDO TRA ENNUPLA E UNA STRUCT\n\t\t\tRust ha un altro tipo di dati che è come un ibrido fra una ennupla e una struct, e si chiama ‘struttura ennupla’. Le strutture ennuple hanno un nome, ma i loro campi no. Sono dichiarate con la parola-chiave struct, e poi con un nome seguito da un'ennupla:\n\n\t\t\t\tstruct Colore(i32, i32, i32);\n\t\t\t\tstruct Punto(i32, i32, i32);\n\n\t\t\t\tlet nero = Colore(0, 0, 0);\n\t\t\t\tlet origine = Punto(0, 0, 0);\n\n\n\t\t\tQui, nero e origine non sono dello stesso tipo, anche se contengono campi degli stessi tipi.\n\n\t\t\tSi può accedere ai membri di una struttura ennupla tramite la notazione a punto o il let destrutturante, proprio come le normali ennuple:\n\n\t\t\t\tlet nero_r = nero.0;\n\t\t\t\tlet Punto(_, origine_y, origine_z) = origine;\n\n\n\n\t\t\tI pattern come Punto(_, origine_y, origine_z) sono usati anche nelle espressioni match.\n\n\t\tUTILITA DELLA STRUTTURA ENNUPLA CON UN SOLO ELEMENTO\n\t\t\tUn caso in cui una struttura ennupla è molto utile è quando ha un solo elemento. Questo viene chiamato il pattern ‘newtype’, perché consente di creare un nuovo tipo che è distinto da quello del suo valore contenuto ed esprime anche un suo significato semantico:\n\n\t\t\t\t//STRUTTURA ENNUPLA CON 1 ELEMENTO PATTERN newtype\n\t\t\t\tstruct Pollici(i32);\t\t\t\t//tipo pollici\t\n\n\t\t\t\t\tlet lunghezza = Pollici(10);   //assegno a lunghezza pollici 10 e creo un nuovo tipo\n\t\t\t\t\t\t\t\t\t\t\t\t   //lunghezza\tdiverso da pollici\n\n\t\t\t\t\tlet Pollici(lunghezza_intera) = lunghezza;   //assegno a pollici lunghezza\n\t\t\t\t\tprintln!(\"la lunghezza è {} pollici\", lunghezza_intera);  //posso stampare lunghezza\n\n\t\t\tCome sopra, si può estrarre il tipo intero interno tramite un let destrutturante. In questo caso, il \n\t\t\t\tlet Pollici(lunghezza_intera) \n\t\t\tassegna 10 a lunghezza_intera. \n\n\t\t\tAvremmo potuto usare la notazione a punto per fare la stessa cosa:\n\t\t\t\tlet lunghezza_intera = lunghezza.0;\n\n\n\t\tALTERNATIVA AD UNA ENNUPLA USARE UNA STRUCT\n\t\t\tÈ sempre possibile usare una struct invece di una struttura ennupla, e può essere più chiara. Avremmo potuto scrivere Colore e Punto anche così:\n\n\t\t\t\t//Creo una struttura al posto di una ennupla = struct Pollici(i32);\n\t\t\t\tstruct Colore {\n\t\t\t\t    rosso: i32,\n\t\t\t\t    blu: i32,\n\t\t\t\t    verde: i32,\n\t\t\t\t}\n\n\t\t\t\t//nella struttura ci sono nomi effettivi non le posizioni come la ennupla\n\t\t\t\t//e puoi utilizzare la notazione a punto es. Punto.x\n\t\t\t\tstruct Punto {\n\t\t\t\t    x: i32,\n\t\t\t\t    y: i32,\n\t\t\t\t    z: i32,\n\t\t\t\t}\n\n\t\t\tI buoni nomi sono importanti, e mentre si può fare riferimento ai valori in una struttura ennupla anche con la notazione a punto, una struct ci dà dei nomi effettivi piuttosto che delle posizioni.\n\tStruct simili a unità \t\t\t\t\t\t\t\t4.12.2\n\t\tNote\n\t\t\tSi può anche definire una struct senza nessun membro:\n\n\t\t\t\t//STRUTTURE SENZA MEMBRO CON GRAFFE O SENZA \n\t\t\t\tstruct Elettrone {} // si usano le graffe vuote...\n\t\t\t\tstruct Protone;     // ...o solo un punto-e-virgola\n\n\t\t\t\t// che la struct sia stata dichiarata con le graffe oppure no,\n\t\t\t\t// si deve fare lo stesso quando se ne istanzia una\n\t\t\t\tlet x = Elettrone {};\n\t\t\t\tlet y = Protone;\n\n\n\t\t\t\tUna tale struct è chiamata ‘simile a unità’ perché somiglia alla ennupla vuota, (), che talvolta è chiamata ‘unità’. Come una struttura ennupla, definisce un nuovo tipo.\n\n\t\t\t\tQuesto tipo è usato raramente da solo (sebbene talvolta può servire come tipo marcatore), ma in combinazione con altre caratteristiche, può diventare utile. Per esempio, una libreria può chiedere di creare una struttura che implementi un certo tratto per gestire eventi. Se non si hanno dati da mettere nella struttura, si può creare struct simile a unità.\n \t\t\n ENUMERAZIONI\t\t\t\t\t\t\t\t\t\t\t4.13.\n\t\tNote\n\t\t\t\t @enumerazioni_(puo essere chiamata @tipo @somma e quindi un tipo @chiave @valore e puo\n\t\t\t\t \t\t\t\tcontenere valori diversi)\n\n\t\t\tUna enumerazione in Rust è un tipo, dichiarato usando la parola-chiave enum, che rappresenta un dato che ha un valore scelto in un elenco di varianti. Ogni variante dell'enumerazione può avere dei dati associati ad essa. Per esempio:\n\t\t\t\t\n\t\t\t\t//enum con dati associati o no  puo contenere dati non definiti, i32 o String\n\t\t\t\tenum Message {\n\n\t\t\t\t\t//solo chiave\n\t\t\t\t    Abbandona,\t\t\t\t\t\t//variante senza dati (sono simili a strutture senza\n\t\t\t\t    \t\t\t\t\t\t\t\t// unita)\n\t\t\t\t    //chiave e valore\t\t\t\t\n\t\t\t\t    CambiaColore(i32, i32, i32),\t//variante con i dati senza nome\n\t\t\t\t    Muovi { x: i32, y: i32 },\t\t//variante con i dati con nome\n\t\t\t\t    Scrivi(String),\n\t\t\t\t}\n\n\t\t\tLa sintassi per definire le varianti somiglia alle sintassi usate per definire le strutture: si possono avere \n\t\t\t\tvarianti senza dati (come le strutture simili a unità), \n\t\t\t\tvarianti con dati con nome, e \n\t\t\t\tvarianti con dati senza nome (come le strutture ennupla). \n\t\t\t\n\t\t\tDiversamente dalle definizioni di strutture distinte, però, un enum è un singolo tipo. \n\t\t\tUn valore di un'enumerazione può corrispondere a una qualunque delle sue varianti. \n\n\t\t\tPer questa ragione, un'enumerazione è talvolta chiamata un \n\t\t\t\t‘tipo somma’: l'insieme dei possibili valori dell'enumerazione è la somma degli insiemi dei possibili valori di ogni variante.\n\n\t\tSINTASSI ::\n\t\t\tUsiamo la sintassi :: per usare il nome di ogni variante: il loro nome può essere usato solo se qualificato dal nome dell'enum stesso. Ciò consente di avere le seguenti dichiarazioni di x e y:\n\t\t\t\tlet x: Messaggio = Messaggio::Mossa { x: 3, y: 4 };\n\n\t\t\t\t\tenum TurnoGiocoDaTavolo {\n\t\t\t\t\t\t//etichetta dei dati Mossa e Passo\n\t\t\t\t\t    Mossa { quadrati: i32 },\t//VARIANTE CON DATI E NOME\n\t\t\t\t\t    Passo,\t\t\t\t\t\t//VARIANTE SOLO NOME SENZA DATI\n\t\t\t\t\t}\n\n\n\t\t\t\t\tlet y: TurnoGiocoDaTavolo = TurnoGiocoDaTavolo::Mossa { quadrato: 1 };\n\n\n\t\t\t\t\tEntrambe le varianti si chiamano Mossa, ma dato che sono qualificate dal nome dell'enumerazione, possono essere usate entrambe senza creare ambiguità.??\n\n\n\t\t\tVALORE ENUM COSA CONTIENE\n\t\t\t\t\t@unione@etichettata(significato delle varianti enum)_@tagged @union\n\n\t\t\t\tUn valore di un tipo enum contiene \n\t\t\t\t\tl'informazione su quale variante è, \n\t\t\t\t\toltre a ogni dato associato a quella variante. \n\n\t\t\t\tQuesto fatto è talvolta indicato come ‘unione etichettata’ [\"tagged union\"], dato che i \n\t\t\t\t\tdati comprendono un'’etichetta’ [\"tag\"], che indica qual'è il tipo. \n\n\t\t\t\tIl compilatore usa questa informazione per garantire che si acceda in modo sicuro ai dati dell'enumerazione. \n\n\t\t\t\tPer esempio, non si può semplicemente provare a destrutturare un valore come se fosse una delle possibile varianti:\n\n\t\t\t\t\tfn elabora_cambio_colore(mess: Messaggio) {\n\t\t\t\t\t\t    let Messaggio::CambiaColore(r, g, b) = mess; // errore di compilazione\n\t\t\t\t\t\t}\n\n\n\n\t\t\t\tCOME SUPERI LA LIMITAZIONE DELLA MANCANZA DI SUPPORTO DELLE OPERAZIONI: Non supportare queste operazioni può sembrare piuttosto limitativo, ma è una limitazione che possiamo superare. \n\t\t\t\tCi sono due modi: o \n\t\t\t\t\timplementando l'uguaglianza noi stessi, \n\t\t\t\t\t\to \n\t\t\t\t\teseguendo un pattern matching delle varianti con espressioni match, come vedremo nella prossima sezione. \n\n\t\t\t\tNon abbiamo ancora visto abbastanza Rust per implementare l'uguaglianza, ma lo vedremo nella sezione sui [tratti][tratti]. ??\n\n\n \tCostruttori come funzioni\t\t\t\t\t\t\t4.13.1\n \t\tNote\n\n\t\t\tUn costruttore di un enum può anche essere usato come una funzione. Per esempio:\n\n\t\t\t\tlet m = Messaggio::Scrivi(\"Ciao, mondo\".to_string());\n\n\t\t\tè lo stesso che\n\t\t\t\t//costruisco la funzione con restituzione \n\t\t\t\tfn foo(x: String) -> Messaggio \n\t\t\t\t\t{\n\t\t\t\t\t    Messaggio::Scrivi(x)\n\t\t\t\t\t}\n\n\t\t\t\t//assegno a x la stringa e chiamo la funzione\n\t\t\t\tlet x = foo(\"Ciao, mondo\".to_string());\n\n\n\n\t\t\tQuesto non ci è immediatamente utile, ma quando arriveremo alle chiusure, parleremo di come \tpassare le funzioni come argomenti ad altre funzioni. \n\n\t\t\tPer esempio, \n\t\t\t\tcon gli iteratori, \n\n\t\t\tpossiamo fare questo per convertire un vettore di String in un vettore di Messaggio::Scrivi:\n\n\t\t\t\t\t//vettore di string convertito in vettore di messaggio\n\n\t\t\t\t\tlet v = vec![\"Ciao\".to_string(), \"Mondo\".to_string()];   //vettore di stringhe\n\n\t\t\t\t\t//conversione vettore di stringhe in vettore di messaggio\n\t\t\t\t\tlet v1: Vec<Messaggio> = v.into_iter().map(Messaggio::Scrivi).collect();\n\n MATCH\t\t\t\t\t\t\t\t\t\t\t\t\t4.14.\n \t\tNote\n \t\t\tSpesso, un semplice if/else non basta, perché ci sono più di due opzioni possibili. Inoltre, le condizioni possono diventare parecchio complesse. Rust ha una parola-chiave, match (\"combacia\"), che consente di sostituire dei complicati raggruppamenti di if/else con qualcosa di più potente. Ecco qua:\n\n \t\t\t\tlet x = 5;\n\n\t\t\t\t\tmatch x {\n\t\t\t\t\t\t//braccio valore espressione\n\t\t\t\t\t    1 => println!(\"uno\"),\n\t\t\t\t\t    2 => println!(\"due\"),\n\t\t\t\t\t    3 => println!(\"tre\"),\n\t\t\t\t\t    4 => println!(\"quattro\"),\n\t\t\t\t\t    5 => println!(\"cinque\"),\n\t\t\t\t\t      => println!(\"qualcos'altro\"),\n\t\t\t\t\t      _  //qui il compilatore inferisce come i32\t\t\t\t\t}\n\n\t\t\tmatch prende un'espressione ed esegue una diramazione in base al suo valore. Ogni ‘braccio’ della diramazione ha la forma valore => espressione. \n\n\t\t\tQuando il valore combacia, l'espressione di quel braccio viene valutata. Viene chiamata match a causa del concetto di ‘pattern matching’, di cui match è un'implementazione. C'è un separate section on patterns che tratta di tutti i pattern che sono ammessi qui.\n\n\t\t\tUno dei molti vantaggi di match è che impone la ‘verifica di esaustività’. Per esempio, se si toglie l'ultimo braccio, quello con il carattere _, il compilatore darà l'errore:\n\t\t\t\t\terror: non-exhaustive patterns: `_` not covered\n\n\t\t\tINFERIMENTO DI X = Rust ci dice che abbiamo dimenticato qualche valore. Il compilatore inferisce dall'x che può avere qualunque valore a 32 bit, da -2.147.483.648 a 2.147.483.647. Il carattere _ agisce da 'prendi-tutto', e prenderà tutti i possibili valori che non sono specificati in un braccio dello stesso match. Come si vede nell'esempio precedente, al match vengono forniti bracci per gli interi da 1 a 5, se x vale 6 o qualunque altro valore, viene preso dal caso _.\n\n\t\t\tESPRESSIONE SU LATO DESTRO = Il costrutto match è anche un'espressione, il che significa che lo si può usare al lato destro di un'istruzione let o direttamente dove è ammessa una espressione:\n\n\t\t\t\tlet x = 5;\n\t\t\t\t\t//Lato destro di =; e gli interi vengono convertiti in stringhe \n\t\t\t\t\tlet numero = match x {\n\t\t\t\t\t    1 => \"uno\",\n\t\t\t\t\t    2 => \"due\",\n\t\t\t\t\t    3 => \"tre\",\n\t\t\t\t\t    4 => \"quattro\",\n\t\t\t\t\t    5 => \"cinque\",\n\t\t\t\t\t    _ => \"qualcos'altro\",\n\t\t\t\t\t};\n\n\n\t\t\t\t\tTalvolta è un modo carino di convertire qualcosa da un tipo a un altro; in questo esempio gli interi vengono convertiti in String.\n\n\n \t\n\tCombaciare le enumerazioni\t\t\t\t\t\t\t4.14.1\n \t\t\tUn altro impiego importante della parola-chiave match sta nell'elaborare le possibili varianti di un'enumerazione:\n\n \t\t\t\tenum Messaggio {\n\t\t\t\t    Abbandona,\n\t\t\t\t    CambiaColore(i32, i32, i32),\n\t\t\t\t    Sposta { x: i32, y: i32 },\n\t\t\t\t    Scrivi(String),\n\t\t\t\t}\n\n\t\t\t\tfn abbandona() { /* ... */ }\n\t\t\t\tfn cambia_colore(r: i32, g: i32, b: i32) { /* ... */ }\n\t\t\t\tfn sposta_cursore(x: i32, y: i32) { /* ... */ }\n\n\t\t\t\tfn elabora_messaggio(msg: Messaggio) {\n\t\t\t\t    match msg {\n\t\t\t\t        Messaggio::Abbandona => abbandona(),\n\t\t\t\t        Messaggio::CambiaColore(r, g, b) => cambia_colorw(r, g, b),\n\t\t\t\t        Messaggio::Sposta { x: x, y: y } => sposta_cursore(x, y),\n\t\t\t\t        Messaggio::Scrivi(s) => println!(\"{}\", s),\n\t\t\t\t    };\n\t\t\t\t}\n\n\n\t\t\t\t\tAncora, il compilatore Rust verifica l'esaustività, e richiede di avere un braccio combaciante per ogni variante dell'enum. Se ne manca qualcuno, darà un errore di compilazione, a meno che si usi il braccio _.\n\n\t\t\t\t\tDiversamente dai precedenti utilizzi di match, questo caso non è sostituibile da un semplice uso del costrutto if. Si può però usare il costrutto if let, che può essere visto come una forma abbreviata di match.\n\n PATTERN\t\t\t\t\t\t\t\t\t\t\t\t4.15.\n \tNote\n \t\t\tI @pattern sono molto comuni in Rust. \n \t\t\tLi usiamo nei \n \t\t\t\tlegami di variabile, \n \t\t\t\tnelle espressioni match, \n\t\t\te anche in altri posti. Facciamo una carrellata di tutte le cose che i pattern possono fare!\n\t\t\tUn rapido ripasso: si può far combaciare direttamente con letterali, e il carattere _ agisce come caso ‘qualunque’:\n\n\t\t\t\tlet x = 1;\n\n\t\t\t\tmatch x {\n\t\t\t\t    1 => println!(\"uno\"),\n\t\t\t\t    2 => println!(\"due\"),\n\t\t\t\t    3 => println!(\"tre\"),\n\t\t\t\t     => println!(\"qualunque cosa\"),\n\t\t\t\t    _                        //_ = significa @caso @qualunque oppure @non@identificato\n\t\t\t\t\n\t\t\t\t}\n\n\n\t\t\t\tQuesto stampa uno.\n\n\t\t\tOSCURAMENTO\n\t\t\t\t\t\t@oscuramento_(esiste anche l'oscuramento tra i @pattern)\n\t\t\t\tC'è un trabocchetto con i pattern: come ogni cosa che introduce un nuovo legame, anche i pattern possono introdurre l'oscuramento. Per esempio:\n\n\t\t\t\t\t\tlet x = 1;\t\t\t//I° legame di x\n\t\t\t\t\t\tlet c = 'c';\n\n\t\t\t\t\t\tmatch c {\n\t\t\t\t\t\tx => println!(\"x: {} c: {}\", x, c),  //II° legame di x che vale c\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprintln!(\"x: {}\", x)  //x esterna oscura la x interna al match stampa 1\n\n\t\t\t\t\tQuesto stampa:\n\n\t\t\t\t\t\tx: c c: c\n\t\t\t\t\t\tx: 1\n\n\n\t\t\t\tIn altre parole, x => combacia con il valore di c e introduce un nuovo legame avente nome x. \n\t\t\t\tQuesto nuovo legame è ha come ambito il braccio di match e prende il valore di c. \n\n\t\t\t\tSi noti che il valore di x all'esterno dell'ambito di match è ininfluente sul valore x al suo interno. Siccome avevamo già un legame chiamato x, questo nuovo x lo oscura.\n\n \tPattern multipli\t\t\t\t\t\t\t\t\t4.15.1\n \t\tNota\n \t\t\tPossiamo far combaciare più pattern usando |:\n \t\t\t\tlet x = 1;\n\n\t\t\t\t\tmatch x {\n\t\t\t\t\t\t//due pattern 1 | 2\n\t\t\t\t\t    1 | 2 => println!(\"uno o due\"), //@pattern @multiplo con |\n\t\t\t\t\t    3 => println!(\"tre\"),\n\t\t\t\t\t    _ => println!(\"qualunque cosa\"),\n\t\t\t\t\t}\n\t\t\t\t\tQuesto stampa uno o due.\n\n \tDestrutturazione\t\t\t\t\t\t\t\t\t4.15.2\t\n \t\tNota\n \t\t\tSe si ha un tipo di dati composito, come una struct, lo si può destrutturare \n \t\t\tdentro un pattern:\n \t\t\t\t\n \t\t\t\tstruct Punto {\n\t\t\t\t\t    x: i32,\n\t\t\t\t\t    y: i32,\n\t\t\t\t\t}\n\n\t\t\t\t\tlet origine = Punto { x: 0, y: 0 };   //nome base x e y\n\n\t\t\t\t\tmatch origine {\n\t\t\t\t\t\t//qua destrutturi in x,y??\n\t\t\t\t\t    Punto { x, y } => println!(\"({},{})\", x, y),\n\t\t\t\t\t}\n\n\n\t\t\tPossiamo usare : per dare un altro nome a un valore.\n\n\t\t\t\tstruct Punto {  //struttura\n\t\t\t\t    x: i32,\n\t\t\t\t    y: i32,\n\t\t\t\t}\n\n\t\t\t\tlet origine = Punto { x: 0, y: 0 };   //nome base x,y\n\n\t\t\t\tmatch origine {\n\t\t\t\t\t//qui dai altro nome, x a x1 e y a y1\n\t\t\t\t    Punto { x: x1, y: y1 } => println!(\"({},{})\", x1, y1),\n\t\t\t\t}\n\n\t\t\tSe ci interessano solamente alcuni valori, non dobbiamo dare dei nomi a tutti:\n\n\t\t\t\tstruct Punto {\n\t\t\t\t    x: i32,\n\t\t\t\t    y: i32,\n\t\t\t\t}\n\n\t\t\t\tlet origine = Punto { x: 0, y: 0 };\n\n\t\t\t\tmatch origine {\n\t\t\t\t\t//forse qui solo la x??\n\t\t\t\t    Punto { x, .. } => println!(\"x is {}\", x),\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tQuesto stampa x è 0.\n\n\n\n\t\t\t\tsi può fare questo genere di match su qualunque membro, non solamente il primo:\n\n\t\t\t\t\tstruct Punto {\n\t\t\t\t\t    x: i32,\n\t\t\t\t\t    y: i32,\n\t\t\t\t\t}\n\n\t\t\t\t\tlet origine = Punto { x: 0, y: 0 };\n\n\t\t\t\t\tmatch origine {\n\t\t\t\t\t    Punto { y, .. } => println!(\"y is {}\", y),\n\t\t\t\t\t}\n\t\t\t\t\tQuesto stampa y è 0.\n\n\t\t\t\t\tQuesto comportamento ‘destrutturante’ funziona su qualunque tipo di dati composito, come le ennuple o le enum.\n\n \tIgnorare i legami\t\t\t\t\t\t\t\t\t4.15.3\n \t\tNote\n \t\t\tSi può usare _ in un pattern per non tener conto del tipo e del valore. Per esempio, ecco un match con un Result<T, E>:\n\n\n\n \t\t\tmatch qualche_valore {\n\t\t\t\t    Ok(valore) => println!(\"preso un valore: {}\", valore),\n\t\t\t\t    Err(_) => println!(\"è avvenuto un errore\"),\n\t\t\t\t}\n\n\t\t\tNel primo braccio, leghiamo il valore dentro la variante Ok a valore. \n\t\t\tMa nel braccio Err, usiamo _ per non tener conto dello specifico errore, e stampiamo un messaggio d'errore generico.\n\n\t\t\tCOME IGNORARE UN ELEMENTO\n\t\t\t\t_ è valido in qualunque pattern che crea un legame. Ciò può essere utile per ignorare parti di una struttura più grande:\n\n\t\t\t\tfn coordinate() -> (i32, i32, i32) {\n\t\t\t\t\t    // genera e restituisci una terna\n\t\t\t\t\t}\n\n\t\t\t\t\tlet (x, _, z) = coordinate();\n\n\t\t\t\tQui, leghiamo il primo e l'ultimo elemento dell'ennupla a x e a z, ma ignoriamo l'elemento di mezzo.\n\n\n\t\t\t\tVale la pena notare che usando _ il valore combaciante non viene affatto legato, il che comporta che tale valore non viene spostato:\n\n\t\t\t\tlet ennupla: (u32, String) = (5, String::from(\"cinque\"));\n\n\t\t\t\t// Qui, ennupla viene spostata, perché l'oggetto String è stato spostato:\n\t\t\t\tlet (x, _s) = ennupla;\n\n\t\t\t\t// La prossima riga darebbe \"error: use of partially moved value: `ennupla`\"\n\t\t\t\t// println!(\"L'ennupla è: {:?}\", ennupla);\n\n\t\t\t\t// Però,\n\n\n\n\t\t\t\tlet ennupla = (5, String::from(\"five\"));\n\n\t\t\t\t// Qui, ennupla _non_ vien spostata, dato che l'oggetto String non è\n\t\t\t\t// mai stato spostato, e l'oggetto u32 è Copy:\n\t\t\t\tlet (x, _) = ennupla;\n\n\t\t\t\t// Ciò comporta che questo funziona:\n\t\t\t\tprintln!(\"L'ennupla è: {:?}\", ennupla);\n\n\n\t\t\t\tCiò comporta anche che ogni variabile temporanea verrà distrutta alla fine dell'istruzione:\n\n\t\t\t\t// Qui, la String creata verrà distrutta immediatamente, dato che non è legata:\n\t\t\t\tlet _ = String::from(\"  hello  \").trim();\n\n\n\n\t\t\t\tSi può usare anche .. in un pattern per ignorare più valori:\n\n\t\t\t\tenum EnnuplaOpzionale {\n\t\t\t\t    Valore(i32, i32, i32),\n\t\t\t\t    Mancante,\n\t\t\t\t}\n\n\t\t\t\tlet x = EnnuplaOpzionale::Valore(5, -2, 3);\n\n\t\t\t\tmatch x {\n\t\t\t\t    EnnuplaOpzionale::Valore(..) => println!(\"Ho un'ennupla!\"),\n\t\t\t\t    EnnuplaOpzionale::Mancante => println!(\"Non ho tale fortuna.\"),\n\t\t\t\t}\n\t\t\t\tQuesto stampa Ho un'ennupla!\n\n \tref e ref mut\t\t\t\t\t\t\t\t\t\t4.15.4\n\n \t\t\t@riferimento_(con let crea un riferimento e mut @riferimento@mutabile)\n\n \t\tSe si vuole ottenere un riferimento, si usi la parola-chiave ref:\n \t\t\tlet x = 5;\n\n\t\t\t\tmatch x {\n\t\t\t\t\t//ref = parola chiave per ottenere un @riferimento\n\t\t\t\t    ref r => println!(\"Ho un riferimento a {}\", r),\n\t\t\t\t}\n\n\t\t\tQuesto stampa Ho un riferimento a 5.\n\n\t\t\tQui, la r dentro il match ha il tipo &i32. In altre parole, la parola-chiave ref crea un riferimento, da usare nel pattern. Se serve un @riferimento @mutabile, ref mut funzionerà allo stesso modo:\n\n\t\t\t\tlet mut x = 5;\n\n\t\t\t\tmatch x {\n\t\t\t\t\t//ref mut = riferimento mutabile\n\t\t\t\t    ref mut mr => println!(\"Ho un riferimento mutabile a {}\", mr),\n\t\t\t\t}\n\n \tGamme\t\t\t\t\t\t\t\t\t\t\t\t4.15.5\n \t\t\t\n \t\t\t@gamme_(@gamma di @valori es da 1 a 5 con 1 ...5)\n\n \t\tSi può far combaciare una gamma di valori usando ...:\n\n \t\tlet x = 1;\n\n\t\t\tmatch x {\n\t\t\t    1 ... 5 => println!(\"da uno a cinque\"),\n\t\t\t    _ => println!(\"qualunque cosa\"),\n\t\t\t}\n\n\t\tQuesto stampa da uno a cinque.\n\t\t\t@utilizzo@gamme_(la gamma di valore vengono usati per gli interi ed i chart)\n\n\t\tLe gamme sono usate per lo più con gli interi e i char:\n\n\t\t\t@esempio@gamma_(di @char)\n\n\t\t\tlet x = '💅';\n\n\t\t\tmatch x {\n\t\t\t    'a' ... 'j' => println!(\"lettera precoce\"),\n\t\t\t    'k' ... 'z' => println!(\"lettera tardiva\"),\n\t\t\t    _ => println!(\"qualcos'altro\"),\n\t\t\t}\n\n\t\t\tQuesto stampa qualcos'altro.\n\n \tLegami\t\t\t\t\t\t\t\t\t\t\t\t4.15.6\n \t\tSi possono legare valori a nomi usando @:\n\n \t\t\t@legami_(si possono legare i valori ai @nome con la chiocciola @)\n\n \t\t\tlet x = 1;\n\n\t\t\t\tmatch x {\n\t\t\t\t\t//lega @ al valore 1 \n\t\t\t\t    e @ 1 ... 5 => println!(\"ho un elemento della gamma: {}\", e),\n\t\t\t\t    _ => println!(\"qualunque cosa\"),\n\t\t\t\t}\n\n\t\t\t\t@operatore@chiocciola_(la@ puo essere utilizzata per le estrazioni complicate)\n\n\t\t\tQuesto stampa ho un elemento della gamma: 1. Questo operatore serve anche quando si vuole estrarre una parte di una struttura dati complicata:\n\n\t\t\t\t\t#[derive(Debug)]\n\t\t\t\t\t\t//creo la struttura persona\n\t\t\t\t\t\tstruct Persona {\n\t\t\t\t\t\t    nome: Option<String>,\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//assegno il valore di stringa a nome\n\t\t\t\t\t\tlet nome = \"Steve\".to_string();\n\t\t\t\t\t\t//assegno a x ??\n\t\t\t\t\t\tlet x: Option<Persona> = Some(Persona { nome: Some(nome) });\n\t\t\t\t\t\tmatch x {\n\t\t\t\t\t\t\t//lego il nome ad a \t??? cosa fa Some  todo: spiegare meglio ?? @non@è@chiaro @devi@studiare@meglio\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t    Some(Persona { nome: ref a @ Some(_), .. }) => println!(\"{:?}\", a),\n\t\t\t\t\t\t    _ => {}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tQuesto stampa Some(\"Steve\"): abbiamo legato il nome interno ad a.\n\n\t\t\t\t\t\tSe si usa @ con |, bisogna assicurarsi che il nome sia legato in ogni parte del pattern:\n\n\t\t\t\t\t\tlet x = 5;\n\n\t\t\t\t\t\tmatch x {\n\t\t\t\t\t\t\t//utilizzo @| = @= 1 e |@ = 8 il nome è legato nel lato dx e sx del pattern\n\t\t\t\t\t\t    e @ 1 ... 5 | e @ 8 ... 10 => println!(\"ho un elemento della gamma: {}\", e),\n\t\t\t\t\t\t    _ => println!(\"qualunque cosa\"),\n\t\t\t\t\t\t}\n\n \tGuardie\t\t\t\t\t\t\t\t\t\t\t\t4.15.7\n \t\t\n \t\t\t@if@nel@match_(la if applicata al match sia con pattern solo dx che dx e sx)\n\n \t\tSi possono introdurre le ‘guardie di match’ usando if:\n \t\t\t//CREO UN ENUM \n \t\t\tenum OptionalInt {\n\t\t\t    Valore(i32),\n\t\t\t    Mancante,\n\t\t\t}\n\t\t\t//assegno a x 5\n\t\t\tlet x = OptionalInt::Valore(5);\n\n\n\n\t\t\tmatch x {\n\t\t\t    //metto la if con il Pattern dx che valuta valore(i)= 5\n\t\t\t    OptionalInt::Valore(i) if i > 5 => println!(\"Ho un int maggiore di cinque!\"),\n\t\t\t    OptionalInt::Valore(..) => println!(\"Ho un int!\"),\n\t\t\t    OptionalInt::Mancante => println!(\"Non ho tale fortuna.\"),\n\t\t\t}\n\n\t\t\t\tQuesto stampa Ho un int!.......\n\n\t\t\tSe si sta usando if con più pattern, la if si applica a entrambi i lati (dx e sx):\n\n\t\t\tlet x = 4;\n\t\t\tlet y = false;\n\n\t\t\tmatch x {\n\t\t\t\t//viene valutata l'espressione 4|5 e quindi stampa si\n\t\t\t\t//la if si applica al pattern dx e a quello sx\n\t\t\t    4 | 5 if y => println!(\"sì\"),\n\t\t\t    _ => println!(\"no\"),\n\t\t\t}\n\n\t\t\t\tQuesto stampa no, perché la if si applica a tutta l'espressione 4 | 5, e non solamente al 5. In altre parole, la precedenza di if si comporta così:\n\n\t\t\t\t\t(4 | 5) if y => ...\n\n\t\t\t\t\tnon così:\n\n\t\t\t\t\t4 | (5 if y) => ...\n\n \tMescolare e abbinare\t\t\t\t\t\t\t\t4.15.8\n \t\tUrca! Ci sono molti modi diversi di far combaciare le cose, e tutti quanti possono essere mescolati e abbinati, a seconda di ciò che si sta facendo:\n\n\t\t\t//match con due @pattern @mescolati ed @abbinati  todo: ???spiegare meglio \n \t\t\tmatch x {\n \t\t\t\t//pattern dx =x  e pattern sx = y\t\t\n\t\t\t    Foo { x: Some(ref nome), y: None } => ...\n\t\t\t}\t\n\n\t\t\tI pattern sono molto potenti. Facciamone buon uso.\n\n SINTASSI DEI METODI\t\t\t\t\t\t\t\t\t4.16.\n \t\n\t\n\tSintassi dei metodi\t\t\t\t\t\t\t\t\t4.16.1\n\t\tLe funzioni sono ottime, ma se si vuole chiamarne un po' su alcuni dati, può diventare scomodo. Si consideri questo codice:\n\n\t\t//ORDINE DI CHIAMATA E INVERSO, prima 1) foo, 2) bar, 3) baz\n\t\tbaz(bar(foo(x)));\n\n\t\t\tNormalmente leggiamo questo codice da sinistra a destra, e quindi diciamo ‘baz di bar di foo di x’. Ma questo non è l'ordine con cui le funzioni verrebbero chiamate; l'ordine di chiamata è invece il contrario: ‘applica a x prima foo, poi bar, e poi baz’. Non sarebbe carino se potessimo scrivere il seguente codice?\n\n\t\tx.foo().bar().baz();\n\t\t\tFortunatamente, come si potrebbe immaginare, si può! Rust fornisce la capacità di usare questa ‘sintassi di chiamata di metodo’ tramite la parola-chiave impl.\n\n\tChiamate di metodo\t\t\t\t\t\t\t\t\t4.16.2\n\t\tEcco come funziona:\n\n\t\t\t//creo una truttura e sua implementazione di cerchio\n\t\t\t//======================================================================//\n\t\t\t\t\t\n\t\t\t\t//STRUTTURA CERCHIO\n\t\t\t\tstruct Cerchio {\n\t\t\t\t    x: f64,\n\t\t\t\t    y: f64,\n\t\t\t\t    raggio: f64,\n\t\t\t\t}\n\n\t\t\t\t//blocco impl con il metodo area\n\t\t\t\timpl Cerchio {\n\t\t\t\t\t//metodo area; con 1 argomento speciale con &self = riferimento immutabile\n\t\t\t\t    fn area(&self) -> f64 {    //CON &SELF = Prendi a prestito regola base al posto del possesso\n\t\t\t\t    \t//calcolo del cerchio con la libreria std f64 const pi = raggio x raggio\n\t\t\t\t        std::f64::consts::PI * (self.raggio * self.raggio)\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t//======================================================================//\n\n\t\t\t//chiamo il cerchio con main\n\t\t\tfn main() {\n\t\t\t\t\t//assegno a c\n\t\t\t\t    let c = Cerchio { x: 0.0, y: 0.0, raggio: 2.0 };\n\t\t\t\t    println!(\"\\n eseguo il calcolo Cerchio passando c con i 3 parametri x, y, raggio : {}\", c.area());\n\t\t\t\t}\n\n\n\t\t\t\tQuesto stamperà 12.566371.\n\n\n\t\t\t\tAbbiamo definito una struct che rappresenta un cerchio. Poi abbiamo scritto un blocco impl, e al suo interno abbiamo definito un metodo, area\n\n\t\t\t\tI metodi prendono un primo argomento speciale, di cui ci sono tre varianti: \n\t\t\t\t\t\tself, \t\t= valore stack\n\t\t\t\t\t\t&self, e \t= riferimento (NON MUTABILE)\n\t\t\t\t\t\t&mut self  \t= riferimento MUTABILE\n\n\t\t\t\t Si può pensare a questo primo argomento come se fosse il foo in foo.bar(). \n\n\t\t\t\t Le tre varianti corrispondono ai tre tipi di cose che foo potrebbe essere: \n\t\t\t\t \tself se è un valore sullo stack, \n\t\t\t\t \t&self se è un riferimento, e \n\t\t\t\t \t&mut self se è un riferimento mutabile. \n\n\t\t\t \tSiccome abbiamo preso l'argomento &self da area, possiamo usarlo come qualunque altro argomento. \n\t\t\t \tSiccome sappiamo che tale argomento è di tipo Cerchio, possiamo accedere al suo membro raggio come faremmo con qualunque altra struct.\n\n\n\t\t\t \tUSARE &SELF COME REGOLA: \n\t\t\t\t \tDi regola dovremmo usare &self, dato che dovremmo preferire prendere a prestito rispetto a prendere il possesso, e pure dovremmo preferire prendere un riferimenti immutabili rispetto a qulli mutabili. Ecco un esempio di tutte e tre le varianti:\n\n\n\t\t\t\t \t\tstruct Cerchio {\n\t\t\t\t\t\t\t    x: f64,\n\t\t\t\t\t\t\t    y: f64,\n\t\t\t\t\t\t\t    raggio: f64,\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\timpl Cerchio {\n\t\t\t\t\t\t\t    fn riferimento(&self) {  //&self = prendi a prestito ed è un riferimento \n\t\t\t\t\t\t\t       println!(\"presa di sé per riferimento!\");\n\t\t\t\t\t\t\t    }\n\n\t\t\t\t\t\t\t    fn riferimento_mutabile(&mut self) {  //&mut self = prendi a mutabile (è prestito o posesso ??)\n\t\t\t\t\t\t\t       println!(\"presa di sé per riferimento mutabile!\");\n\t\t\t\t\t\t\t    }\n\n\t\t\t\t\t\t    fn prendi_possesso(self) {  //self nello stack e poi finisce con l'ambito delle {}\n\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tSi possono usare tanti blocchi impl quanti se ne vuole. L'esempio precedente poteva anche essere scritto così:\n\n\t\t\t\t\t\t\t//esempio di implementazione con 3 blocchi\n\t\t\t\t\t\t\tstruct Cerchio {\n\t\t\t\t\t\t\t    x: f64,\n\t\t\t\t\t\t\t    y: f64,\n\t\t\t\t\t\t\t    raggio: f64,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//blocco cerchio con &self\n\t\t\t\t\t\t\timpl Cerchio {\n\t\t\t\t\t\t\t    fn riferimento(&self) {\n\t\t\t\t\t\t\t       println!(\"presa di sé per riferimento!\");\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//blocco cerchio con  &mut self = nella memoria heap ed è mutabile\n\t\t\t\t\t\t\timpl Cerchio {\n\t\t\t\t\t\t\t    fn riferimento_mutabile(&mut self) {  \n\t\t\t\t\t\t\t       println!(\"presa di sé per riferimento mutabile!\");\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//blocco cerchio con  solocon self = nello stack\n\t\t\t\t\t\t\timpl Cerchio {\n\t\t\t\t\t\t\t    fn prendi_possesso(self) {\n\t\t\t\t\t\t\t       println!(\"presa di possesso di sé!\");\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t}\n\n\tConcatenamento di chiamate di metodi\t\t\t\t4.16.3\n\t\tPerciò, adesso sappiamo come chiamare un metodo, come foo.bar(). \n\t\tE che dire del nostro esempio originale, x.foo().bar().baz()? \n\t\tQuesto è chiamato ‘concatenamento di metodi’. Vediamo un esempio:\n\t\t\t\n\t\t\t//CONCATENAMENTO DI CHIAMATE DI METODI\n\t\t\t \t//=====================================================================================//\n\n\t\t\t\t\t//faccio la struttura cerchio\n\t\t\t\t\t\t#[derive(Debug)]        //macro di debug per evitare errori\n\t\t\t\t\t\t#[allow(dead_code)]   //elimina il warning sul codice non usato\n\t\t\t\t\t\tstruct Cerchio {\n\t\t\t\t\t\t    x: f64,\n\t\t\t\t\t\t    y: f64,\n\t\t\t\t\t\t    raggio: f64,\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//implemento il cerchio con una funzione new (3 parametri x, y,raggio) --> restituisce Cerchio\n\t\t\t\t\t\timpl Cerchio {\n\t\t\t\t\t\t    fn new(x: f64, y: f64, raggio: f64) -> Cerchio {\n\t\t\t\t\t\t        Cerchio {\n\t\t\t\t\t\t            x: x,           //assegna valore 1 parametro\n\t\t\t\t\t\t            y: y,           //assegna valore 2 parametro\n\t\t\t\t\t\t            raggio: raggio, //assegna valore 3 parametro\n\t\t\t\t\t\t        }\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfn main() {\n\t\t\t\t\t\t    //chiamo il metodo o la funzione statica con Cerchio::new che prende un argomento self (immutabile)\n\t\t\t\t\t\t    let c = Cerchio::new(0.0, 0.0, 2.0);\n\t\t\t\t\t\t    println!(\"ESEMPIO di concatenamento di metodi, area = {:?}\", c);\n\t\t\t\t\t\t}\n\n\t\t\t \t//=====================================================================================//\n\n\n\t\t\t \tVerifica il tipo del valore restituito:\n\t\t\t \t//posso inserire un'altra funzione chiamata grow ...\n\t\t\t\tfn grow(&self, increment: f64) -> Cerchio {\n\t\t\t\tDiciamo che stiamo restituendo un Cerchio. Con questo metodo, possiamo far crescere un nuovo Cerchio a qualunque dimensione.\n\n\n\n\n\tFunzioni associate\t\t\t\t\t\t\t\t\t4.16.4\n\t\t\n\t\t\t@metodi@di@classe_(sono funzione associate in una struct dette @funzioni@statiche )\n\t\tSi possono anche definire funzioni associate che non prendono un argomento self. \n\t\tEcco un pattern molto comune nel codice Rust:\n\n\t\t\t//faccio la struttura cerchio\n\t\t\tstruct Cerchio {\n\t\t\t\t    x: f64,\n\t\t\t\t    y: f64,\n\t\t\t\t    raggio: f64,\n\t\t\t\t}\n\n\t\t\t\t//implemento il cerchio con una funzione new (3 parametri x, y,raggio) --> restituisce Cerchio\n\t\t\t\timpl Cerchio {\n\t\t\t\t    fn new(x: f64, y: f64, raggio: f64) -> Cerchio {\n\t\t\t\t        Cerchio {\n\t\t\t\t            x: x,\t\t\t\t//assegna valore 1 parametro\n\t\t\t\t            y: y,\t\t\t\t//assegna valore 2 parametro\n\t\t\t\t            raggio: raggio,\t\t//assegna valore 3 parametro\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t\t\tfn main() {\n\t\t\t\t\t\t\t//chiamo il metodo o la funzione statica con Cerchio::new che prende un argomento self (immutabile)\n\t\t\t\t    let c = Cerchio::new(0.0, 0.0, 2.0);\n\t\t\t\t}\n\n\t\t\t\tQuesta ‘funzione associata’ ci costruisce un nuovo Cerchio. \n\n\t\t\t\tSi noti che le funzioni associate vengono chiamate usando la sintassi Struct::function(), invece che con la sintassi ref.method(). \n\t\t\t\t\t\t@funzioni@statiche_(sono le funzione associate dette metodi di classe o @funzioni@associate)\n\n\t\t\t\tIn alcuni altri linguaggi, le funzioni associate sono chiamate ‘funzioni membro statiche’ o ‘metodi statici’ o ‘metodi di classe’.\n\n\n\tIl pattern del costruttore\t\t\t\t\t\t\t4.16.5\n\t\t\tDiciamo che vogliamo che i nostri utenti possano creare delle istanze di Cerchio, \n\t\t\tma permetteremo loro di impostare solamente le proprietà a cui sono interessati. \n\n\t\t\tSe non specificati, gli attributi x e y varranno 0.0, e l'attributo raggio varrà 1.0. \n\n\t\t\tRust non ha il sovraccaricamento dei metodi, né gli argomenti con nome, né un numero variabile di argomenti. \n\n\t\t\tInvece si impiega il pattern del costruttore. Si presenta così:\n\n\n\t\t\t//COME FARE UN COSTRUTTORE IN RUST\n\t\t\t \t//=====================================================================================//\n\n\n\t\t\t\t\t//struttura\n\t\t\t\t\tstruct Cerchio {\n\t\t\t\t\t\t    x: f64,\n\t\t\t\t\t\t    y: f64,\n\t\t\t\t\t\t    raggio: f64,\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t//implementazione\n\t\t\t\t\t\timpl Cerchio {\n\t\t\t\t\t\t\t//calcolo AREA cerchio\n\t\t\t\t\t\t    fn area(&self) -> f64 {\n\t\t\t\t\t\t        std::f64::consts::PI * (self.raggio * self.raggio)\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//costruttore di cerchi con 3 parametri x,y,raggio\n\t\t\t\t\t\tstruct CostruttoreDiCerchi {\n\t\t\t\t\t\t    x: f64,\n\t\t\t\t\t\t    y: f64,\n\t\t\t\t\t\t    raggio: f64,\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//CREO I METODI nel costruttore che permette di costruire il cerchio finale con la funzione finalizza\n\t\t\t\t\t\timpl CostruttoreDiCerchi {\n\t\t\t\t\t\t    fn new() -> CostruttoreDiCerchi {\n\t\t\t\t\t\t        CostruttoreDiCerchi { x: 0.0, y: 0.0, raggio: 1.0, }\n\t\t\t\t\t\t    }\n\n\t\t\t\t\t\t    // coordinata x \n\t\t\t\t\t\t    fn x(&mut self, coordinata: f64) -> &mut CostruttoreDiCerchi {\n\t\t\t\t\t\t        self.x = coordinata;\n\t\t\t\t\t\t        self\n\t\t\t\t\t\t    }\n\n\t\t\t\t\t\t    // coordinata y\n\n\t\t\t\t\t\t    fn y(&mut self, coordinata: f64) -> &mut CostruttoreDiCerchi {\n\t\t\t\t\t\t        self.y = coordinata;\n\t\t\t\t\t\t        self\n\t\t\t\t\t\t    }\n\n\t\t\t\t\t\t    // I metodo il raggio\n\t\t\t\t\t\t    fn raggio(&mut self, raggio: f64) -> &mut CostruttoreDiCerchi {\n\t\t\t\t\t\t        self.raggio = raggio;\n\t\t\t\t\t\t        self\n\t\t\t\t\t\t    }\n\n\t\t\t\t\t\t    // II metodo finalizza\n\t\t\t\t\t\t    fn finalizza(&self) -> Cerchio {\n\t\t\t\t\t\t    \tprintln!(\"\\n \n\t\t\t\t\t\t    mi trovo nel METODO FINALIZZA e chiamo la classe cerchio \n\t\t\t\t\t\t    passando i valori di   x: {},  \t\\n\n\t\t\t\t\t\t    passando i valori di   y: {} e \t\\n\n\t\t\t\t\t\t    passando il valore del raggio {}  \\n\", self.x, self.y, self.raggio);\n\n\t\t\t\t\t\t        Cerchio { x: self.x, y: self.y, raggio: self.raggio }  //chiamo cerchio passando 3 paramtri\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfn main() {\n\t\t\t\t\t\t\t//Chiamo il costruttore dell'istanza di cerchi con new\n\t\t\t\t\t\t    let c = CostruttoreDiCerchi::new()\t\t\n\t\t\t\t\t\t        .x(1.0)\t\t\t\t//passo la coordinata x\n\t\t\t\t\t\t        .y(2.0)\t\t\t\t//passo la coordinata y\n\t\t\t\t\t\t        .raggio(2.0)\t\t//passo i valori del raggio\n\t\t\t\t\t\t        .finalizza();\t\t//costruisco il cerchio\n\n\t\t\t\t\t\t    println!(\"\n\t\t\t\t\t\t    calcolo area: {}\", c.area());     //CHIAMO il metodo area per il calcolo del cerchio raggio x raggio\n\t\t\t\t\t\t    println!(\"\n\t\t\t\t\t\t    valore di  x: {}\", c.x);\n\t\t\t\t\t\t    println!(\"  \n\t\t\t\t\t\t    valore di  y: {}\", c.y);\n\t\t\t\t\t\t    }\n\n \t\t\t\t\t//=====================================================================================//\n\n \t\t    STRUTTURA COSTRUTTORI CERCHI\t\t\t\n \t\t\tCiò che abbiamo fatto qui è creare un'altra struct, CostruttoreDiCerchi. \n\n \t\t\t\t\tSu di essa abbiamo definito i nostri metodi di costruttore. \n\n \t\t\t\t\tAbbiamo anche definito il nostro metodo area() su Cerchio. \n \t\t\t\t\tInoltre abbiamo creato un altro metodo su CostruttoreDiCerchi: \n \t\t\t\t\t\tfinalizza(). \n\t\t\t\t\tQuesto metodo crea il nostro Cerchio finale dal costruttore. Adesso, abbiamo usato il sistema dei tipi per imporre le nostre intenzioni: possiamo usare i metodi su CostruttoreDiCerchi per vincolare la costruzione di istanze di Cerchio in qualunque modo desideriamo.\n\n\n  STRINGHE\t\t\t\t\t\t\t\t\t\t\t\t4.17.\n  \tLe stringhe\t\t\t\t\t\t\t\t\t\t\t4.17.1\n  \t\tLe stringhe sono un concetto di cui è importante che ogni programmatore si impadronisca. Il sistema di gestione delle stringhe di Rust è un po' diverso da quello degli altri linguaggi, a causa del suo incentrarsi sulla programmazione di sistema. Ogni volta che c'è una struttura dati di dimensione variabile, le cose possono complicarsi, e le stringhe sono una struttura dati ridimensionabile. Detto questo, le stringhe di Rust funzionano diversamente anche da alcuni altri linguaggi di sistema, come il C.\n\n\t\tScaviamo nei dettagli. Una ‘stringa’ è una sequenza di valori scalari Unicode codificati come flusso di byte UTF-8. Tutte le stringhe sono garantite essere una ecodifica valida di sequenze UTF-8. In aggiunta, diversamente da alcuni linguaggi di sistema, le stringhe non hanno un carattere terminatore e possono contenere il carattere NUL, rappresentato dal byte 0.\n\t\t\t@stringa_(sequenza di valori scalari Unicode UTF-8 senza terminatore ma hanno @nul)\n\n\t\tRust ha due principali tipi di stringhe: \n\t\t\t&str \t\t= chiamate slice di stringa (a dimensione fissa ed una sequenza di byte UTF-8)\n\t\t\t\te \n\t\t\tString. \t= stringa variabile sull'Heap\n\n\t\tDapprima parliamo di &str. Queste sono chiamate ‘slice di stringa’. Una slice di stringa ha una dimensione fissa, e non può essere modificata. È un riferimento a una sequenza di byte UTF-8.\n\n\t\t\tlet saluto = \"Ciao là.\"; // saluto: &'static str\n\n\t\t\"Ciao là.\" è un letterale di stringa il cui tipo è &'static str. \n\n\t\t\t\t@&str_(slice di stringa allocato staticamente nel programma compilato)\n\n\t\tUn letterale di stringa è uno slice di stringa che è allocato staticamente, il che significa che è salvato dentro il nostro programma compilato, ed esiste per l'intera durata dell'esecuzione. Il legamo saluto è un riferimento a questa stringa staticamente allocata. Qualunque funzione che si aspetta una slice di stringa accetterà anche un letterale di stringa.\n\n\n\t\tSI ESTENDONO SU PIU RIGHE: I letterali di stringa possono estendersi su più righe. Ce ne sono due forme. La prima includerà i caratteri a-capo e gli spazi che li seguono:\n\n\t\t\tI° \tFORMA\n\t\t\t\t//qui si sono gli accapo e gli spazi\n\t\t\t\tlet s = \"foo\n    \t\t\t\tbar\";\n\n\t\t\t\tassert_eq!(\"foo\\n    bar\", s);\n\n\t\t\tII° FORMA\n\t\t\t\tLa seconda, con un \\, rimuove gli a-capo e gli spazi che li seguono:\n\n\t\t\t\t// attenzione se metta la \\ vengono rimossi gli spazi e gli accapo seguenti\n\t\t\t\tlet s = \"foo\\\n\t\t\t\t    bar\";\n\n\t\t\t\tassert_eq!(\"foobar\", s);\n\n\t\t\tTIPO NON DIMENSIONATO : Si noti che normalmente non si può accedere direttamente a una str, ma solamente tramite un riferimento &str. Questo perché str è un tipo non dimensionato che richiede informazioni aggiuntive in fase di esecuzione per poter essere usata. Per avere maggiori informazioni, si veda il capitolo sui tipi non dimensionati.\n\n\t\t\tSTRING MEMORIZZATO SULL'HEAP ED E' ESTENSIBILE = Però Rust ha di più oltre alle &str. Una String è una stringa allocata sullo heap. Questa string è estendibile, ed è anche garantita essere UTF-8. \n\t\t\t\n\t\t\tMETODO to_String CONVERTE UNA SLICE DI STRING = Le String tipicamente sono create convertendo una slice di stringa, usando il metodo to_string.\n\t\t\t\t@Metodo@to_String_(converte le slice di stringa da str a String)\n\n\t\t\tLe String vengono forzate ad essere un &str usando un &:\n\n\t\t\t\t\t//&str = Forzatura di String che viene riconvertita in str\n\t\t\t\tfn prendi_slice(slice: &str) {\n\t\t\t\t    println!(\"Preso: {}\", slice);\n\t\t\t\t}\n\n\t\t\t\tfn main() {\n\t\t\t\t    let s = \"Ciao\".to_string();  //to_string converte una slice di stringa in String\n\t\t\t\t    prendi_slice(&s);\n\t\t\t\t}\n\n\t\t\tCONVERSIONE OBBLIGATORIA CON &* = Questa forzatura non avviene per le funzioni che accettano uno dei tratti di &str invece di &str stessa?. Per esempio, \n\t\t\t\tTcpStream::connect ha un argomento di tipo ToSocketAddrs. \n\n\t\t\t\tUna &str va bene, ma una String deve essere esplicitamente convertita usando &*.\n\n\t\t\t\tuse std::net::TcpStream;\n\n\t\t\t\tTcpStream::connect(\"192.168.0.1:3000\"); // argomento di tipo &str\n\n\t\t\t\tlet stringa_indirizzo = \"192.168.0.1:3000\".to_string();\n\t\t\t\tTcpStream::connect(&*stringa_indirizzo); \n\n\t\t\tCOSTO DELLA CONVERSIONE = Vedere una String come una &str costa poco, ma convertire la &str in una String comporta allocare della memoria. Non c'è ragione di farlo, a meno che sia necessario!\n\n\n \tIndicizzazione\t\t\t\t\t\t\t\t\t\t4.17.2\n\n \t\t\t@indice@stringa_(vietato perchè costoso e la stringa puo essere anche punti)\n\n \t\tNO INDICIZZAZIONE = Siccome le stringhe sono UTF-8 valide, non supportano l'indicizzazione:\n \t\t\tlet s = \"ciao\";\n\t\t\tprintln!(\"La prima lettera di s è {}\", s[0]); // ERRORE!!!\t\t\n\n\t\tSolitamente, l'accesso a un vettore con [] è molto veloce. Ma, siccome ogni carattere una stringa codificata in UTF-8 può occupare più byte, si deve percorrere la stringa per trovare l'ennesima lettera di una stringa. Questa è un'operazione significativamente più costosa, e non si vuole essere fuorvianti. \n\t\tInoltre, il concetto di ‘lettera’ non è qualcosa di ben definito in Unicode. Possiamo scegliere di guardare una stringa come una sequenza di singoli byte, o come punti di codice [\"codepoint\"]:\n\n\t\tlet hachiko = \"忠犬ハチ公\";\n\n\t\t\tfor b in hachiko.as_bytes() {\n\t\t\t    print!(\"{}, \", b);\n\t\t\t}\n\n\t\t\tprintln!(\"\");\n\n\t\t\tfor c in hachiko.chars() {\n\t\t\t    print!(\"{}, \", c);\n\t\t\t}\n\n\t\t\tprintln!(\"\");\n\n\t\t\tQuesto stampa:\n\n\t\t\t229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,\n\t\t\t忠, 犬, ハ, チ, 公,\n\n\t\t\t\n\t\t\tSi può ottenere qualcosa di simile a un indice in questo modo:\n\n\t\t\tlet dog = hachiko.chars().nth(1); // un po' come hachiko[1]\n\t\t\tQuesto evidenzia che dobbiamo percorrere la lista di char dall'inizio.\n\n\n\n\n\n \tAffettatura [\"slicing\"]\t\t\t\t\t\t\t\t4.17.3\n\n \t\t\t@slicing_(come @affettare una stringa @offset in caratteri non in @byte)\n\n \t\tSi può ottenere una slice di una stringa con la sintassi dell'affettatura:\n\n \t\t\tfn main() {\n\t\t\t    let dog = \"hachiko\";    \t//stringa\n\t\t\t\tlet hachi = &dog[0..5];     //slicing stringa ma non andare fuori indice : NO 0...6 FUORI INDICE\n\t\t\t\tprint!(\"slicing di string è ammesso da 0..5= {}, \", hachi);\n\n\t\t\t\t}\n\n\t\tMa si noti che questi sono offset in byte, non offset in caratteri. Perciò questo fallirà in fase di esecuzione:\n\t\t\t@slicing@byte_(in byte non avviene lo slicing ma da errore)\n\n\t\t\t//questi sono  byte non stringhe \n\t\t\tlet dog = \"忠犬ハチ公\";\n\t\t\tlet hachi = &dog[0..2];\t\t\t//slicing errore perche in byte\n\n\t\tcon questo errore:\n\n\t\t\tthread 'main' panicked at 'index 0 and/or 2 in `忠犬ハチ公` do not lie on\n\t\t\tcharacter boundary'\n\n \tConcatenazione\t\t\t\t\t\t\t\t\t\t4.17.4\n\n \t\tAvendo una String, si può concatenare una &str alla sua fine:\n\n \t\t\tfn main() {\n\t\t\t\t//esempio CON UNA STRING\n\t\t\t\tlet ciao = \"Ciao \".to_string();   //la String che viene deferenziata in &string\n\t\t\t\tlet mondo = \"mondo!\";\n\n\t\t\t\t//puoi concatenare le due string\n\t\t\t\tlet ciao_mondo = ciao + mondo;\n\t\t\t\tprint!(\"concateno ciao + mondo = {}, \", ciao_mondo);\n\t\t\t\t}\n\n\n\n\t\t\tMa se avendo due String, serve un &:\n\n\t\t\t\tfn main() {\n\t\t\t\t    let ciao = \"Ciao \".to_string();  //QUI ABBIAMO LA I° STRING \n\t\t\t\tlet mondo = \"mondo!\".to_string();     //QUI ABBIAMO LA  II° STRING \n\n\t\t\t\tlet ciao_mondo = ciao + &mondo;     //DEVI DEFERENZIARE LA STRING con &string\n\t\t\t\tprint!(\"concateno ciao + mondo  = {}, \", ciao_mondo);\n\t\t\t\t}\n\n\t\t\tQuesto perché &String può essere automaticamente forzata in un &str. \n\t\t\tQuesta caratteristica si chiama ‘forzatura Deref’.\n\n GENERICITÀ\t\t\t\t\t\t\t\t\t\t\t\t4.18.\n \tI generici\t\t\t\t\t\t\t\t\t\t\t4.18.1\n\n \t\tPOLIMORFISMO PARAMETRICO\n\t \t\tTalvolta, quando si scrive una funzione o un tipo di dati, potremmo volere che funzioni per più tipi di argomenti. In Rust, lo possiamo fare usando i generici. Nella teoria dei tipi, i generici sono chiamati ‘polimorfismo parametrico’, che significa che sono tipi o funzioni che hanno più forme (in greco ‘poli’ significa ‘plurimo‘, e ‘morfo’ significa ‘forma‘) in base a un dato parametro (da cui ‘parametrico’).\n\n\t \t\tComunque, basta così con la teoria dei tipi, guardiamo del codice generico. La libreria standard di Rust fornisce un tipo, Option<T>, che è generico:\n\n\t \t\t\t@Tipo@generico_(argomenti con @tipi@generici, @Option<T> quindu UN GENERICO CON UN SOLO TIPO)\n\n\t \t\t\t//TIPO GENERICO SINGOLO\n\t \t\t\tenum Option<T> {\n\t\t\t\t\t    Some(T),\n\t\t\t\t\t    None,\n\t\t\t\t\t}\n\n\t\t\t\n\t\t\t\t\t@tipo@generico_(viene indicata con <T> il tipo generico @singolo)\n\n\t\t\tLa parte <T>, che abbiamo già visto alcune volte, indica che questo è un tipo di dati generico. Ogni volta che nel nostro codice usiamo questo enum, specifichiamo un tipo che sostituisce il parametro T ogni volta che compare nella dichiarazione generica. Ecco un esempio di uso di Option<T>, con un'annotazione di tipo aggiuntiva:\n\n\n\t\t\t\t//SX E DX LE dichiarazioni combaciano in quanto sul lato sx Option<T> = è di tipo i32\n\t\t\t\t//\t\t\t\t\t\t\t\t\t\t\t\tsul lato sx Some = 5  indica che Some(T) è intero di tipo i32\n\n\n\t\t\t\tlet x: Option<i32> = Some(5);\n\n\t\t\t\tNella dichiarazione di tipo, diciamo Option<i32>. \n\t\t\t\tSi noti quanto simile appaia a Option<T>. \n\n\t\t\t\tQuindi, in questa particolare Option, T ha il valore di i32. Sul lato destro del legame, costruiamo un Some(T), dove l'oggetto di tipo T è 5. \n\n\t\t\t\tDato che si tratta di un i32, i due lati combaciano, e Rust è contento. \n\n\t\t\t\tSe non combaciassero, otterremmo un errore:\n\n\n\t\t\t\t//errore perche due tipi diversi di <T>\n\t\t\t\tlet x: Option<f64> = Some(5);\n\n\t\t\t\t// error: mismatched types: expected `core::option::Option<f64>`,\n\t\t\t\t// found `core::option::Option<_>` (expected f64 but found integral variable)\n\n\n\n\t\t\t\tATTENZIONE UGUAGLIANZA SOLO NEI DUE LATI MA OTPION DIVERSI\n\n\n\t\t\t\tCiò non significa che non si possono costruire degli Option<T> che tengono f64! Solamente i due lati dell'assegnamento devono avere lo stesso tipo:\n\n\t\t\t\t\t//OTPION <T> diversi ma con lati uguali\n\n\t\t\t\t\tlet x: Option<i32> = Some(5);\t\t\t//i32\n\t\t\t\t\tlet y: Option<f64> = Some(5.0f64);\t\t//f64\n\n\n\t\t\t\tCosì va bene. Una sola definizione, utilizzi multipli.\n\n\n\t\t\t\tGENERICI CON DUE TIPI\n\n\t\t\t\t\tI generici non sono limitati ad essere parametrizzati da un solo tipo. Si consideri un altro tipo simile, fornito dalla liberia standard di Rust, Result<T, E>:\n\n\t\t\t\t\t\t//TIPO GENERICO CON DUE TIPI \n\t\t\t\t\t\tenum Result<T, E> {\n\t\t\t\t\t\t\t\t\t    Ok(T),\n\t\t\t\t\t\t\t\t\t    Err(E),\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\tQuesto tipo è generico relativamente a due tipi: T ed E. Tra l'altro, le lettere maiuscole possono essere qualunque lettera si gradisca. Si sarebbe potuto definire Result<T, E> come:\n\n\t\t\t\t\t\t\t//TIPO GENERICO DOPPIO\n\t\t\t\t\t\t\tenum Result<A, Z> {\n\t\t\t\t\t\t\t    Ok(A),\n\t\t\t\t\t\t\t    Err(Z),\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\tse si avesse voluto. \n\n\t\t\t\t\tPer convenzione il primo parametro generico dovrebbe essere T, per ‘tipo’, e si dovrebbe usare E per ‘errore’. Però a Rust non importa.\n\n\t\t\t\t\t\t@TIPI@GENERICI@DOPPI_(come il Result per con due tipi T,E per restituire un errore in caso di fallimento dell'elaborazione)\n\n\t\t\t\t\tIl tipo Result<T, E> è pensato per essere usato come risultato di un'elaborazione, dando la possibilità di rendere un errore nel caso non si riuscisse a completare correttamente l'elaborazione.\n\n \tFunzioni generiche\t\t\t\t\t\t\t\t\t4.18.2\n \t\t\n \t\t\t@funzione@generica@un@tipo_(funzione con UN TIPO T)\n\n \t\tSi possono scrivere funzioni che prendono tipi generici, usando una sintassi simile:\n\n \t\t\t\n \t\t\t//@funzione@generica\n \t\t\tfn prende_qualunque_cosa<T>(x: T) {\n \t\t\t   // fai qualcosa con x\n\t\t\t\t}\n\n\t\t\t\tLa sintassi ha due parti: \n\t\t\t\t\tla <T> dice “questa funzione è generica rispetto a un tipo, T”, e la \n\t\t\t\t\tx: T dice “x è di tipo T.”\n\n\n\t\t\t@funzione@generica@DUE@STESSO@tipo_(funzione con DUE TIPO T O PIU ARGOMENTI)\n\n\t\t\t\tPiù argomenti possono essere dello stesso tipo generico:\n\n\t\t\t\t\t//TIPO DI CON DUE PARAMETRI OGGETTI DELLO STESSO TIPO X,Y\n\t\t\t\t\tfn prende_due_oggetti_del_medesimo_tipo<T>(x: T, y: T) {\n   \t\t\t\t\t\t // ...\n\t\t\t\t\t\t\t}\n\n\n\n\t\t\t\tSi può anche scrivere una versione che prende più tipi:\n\t\t\t\t\t\n\t\t\t\t\t@funzione@generica@DUE@tipI_(funzione con DUE @TIPO@T)\n\n\t\t\t\t\t@funzione@generica@DUE@OGGETTI@DIVERSI_(funzione con @DUE@OGGETTI@DIVERSI DI TIPO T,U)\n\n\t\t\t\t//DUE OGGETTI CON TIPO DIVERSO T,U\n\t\t\t\tfn prende_due_oggetti<T, U>(x: T, \n\t\t\t\t\t                        y: U) {\n\t\t\t\t\t\t    // ...\n\t\t\t\t\t\t}\n\n\tStruct generiche\t\t\t\t\t\t\t\t\t4.18.3\n\n\t\t\t@TIPI@GENERICI@struct_(I TIPI GENERICI SI APPLICANO  @campi della struct )\n\n\t\t\t\tSi può usare un tipo generico anche per i campi di una struct:\n\n\t\t\t\t\t@definizione@struttura@generica_(definita con parametro di tipo <T>)\n\n\t\t\t\t\t//NELLA DEFINIZIONE DELLA STRUTTURA GENERICA il parametro è di tipo T con due campi di tipo T\n\n\t\t\t\t\tstruct Punto<T> {\n\t\t\t\t\t    x: T,\n\t\t\t\t\t    y: T,\n\t\t\t\t\t}\n\n\t\t\t\t\t// un tipo T = intero + secondo tipo T = virgola mobile\n\t\t\t\t\tlet origine_intera = Punto { x: 0, y: 0 };\n\t\t\t\t\tlet origine_a_virgola_mobile = Punto { x: 0.0, y: 0.0 };\n\n\n\t\t\t\tIMPLEMENTAZIONE DELLA STRUTTURA GENERICA\n\t\t\t\tQuando si vuole aggiungere un'implementazione per una struct generica, si dichiara il parametro di tipo subito dopo la impl:\n\n\t\t\t\t//Implementazione tipo T + parametro di tipo T (Punto <T>)\n\t\t\t\timpl<T> Punto<T> {\n\t\t\t\t\t    fn swap(&mut self) {\n\t\t\t\t\t        std::mem::swap(&mut self.x, &mut self.y);\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\n\t\t\t\tFinora abbiamo visto dei generici che prendono assolutamente qualunque tipo. \n\n\t\t\t\tQuesti servono in molti casi: \n\t\t\t\t\tabbiamo già visto Option<T>, \n\t\t\t\t\te poi incontreremo i tipi contenitore universali, come Vec<T>. \n\n\t\t\t\tD'altra parte, spesso si vuole rinunciare a quella flessibilità per avere un maggior poter espressivo. Si legga la sezione sui legami di tratto per vedere come e perché.\n\n TRATTI\t\t\t\t\t\t\t\t\t\t\t\t\t4.19.\n \tTratti [\"trait\"]\t\t\t\t\t\t\t\t\t4.19.1\n \t\ttrait\n \t\t\tUn tratto è una caratteristica del linguaggio che dice al compilatore Rust quali funzionalità un tipo deve fornire.\n \t\t\t\t\t@tratto_(@trait= @classe@astratta o una @firma che permette di definire le funzionalita di un tipo)\n\n \t\t\tRicordiamo la parola-chiave impl, usata per chiamare una funzione con la sintassi dei metodi:\n\n \t\t\t\t\n \t\t\t\t//differenza tra la struttura implementata ed il tratto; questa è una struttura\n \t\t\t\t//struttura\n \t\t\t\tstruct Cerchio {\n\t\t\t\t\t    x: f64,\n\t\t\t\t\t    y: f64,\n\t\t\t\t\t    raggio: f64,\n\t\t\t\t\t}\n\n\t\t\t\t\t//implementa la struttura\n\t\t\t\t\t//impl = parola chiave utilizzata per chiamare una funzione con sintassi dei metodi\n\t\t\t\t\t//impl contiene il metodo non la firma\n\t\t\t\t\timpl Cerchio {\t\t\t//impl Item\n\t\t\t\t\t    fn area(&self) -> f64 {\n\t\t\t\t\t        std::f64::consts::PI * (self.raggio * self.raggio)\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\n\t\t\t\t//qui abbiamo un tratto che si differenza dalla struttura perchè prima la firma dopo l'implemetazione\n\n\t\t\t\t//struttura cerchio uguale\n\t\t\t\t\tstruct Cerchio {\n\t\t\t\t\t    x: f64,\n\t\t\t\t\t    y: f64,\n\t\t\t\t\t    raggio: f64,\n\t\t\t\t\t}\n\n\n\t\t\t//firma del tratto ed implementazione\n\t\t\t//---------------------------------------------------------------------------//\n\t\t\t\t//prima la firma = blocco trait\n\t\t\t\ttrait HaArea {\n\t\t\t\t\t    fn area(&self) -> f64;\t\t//firma del tipo senza implementazione\n\t\t\t\t\t}\n\n\t\t\t\t\t//implementazione del tratto  = blocco impl \n\t\t\t\t\timpl HaArea for Cerchio {\t\t//impl Trait for Iterm\n\t\t\t\t\t    fn area(&self) -> f64 {\n\t\t\t\t\t        std::f64::consts::PI * (self.raggio * self.raggio)\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t//---------------------------------------------------------------------------//\n\n\t\t\t\tCome si può vedere, \n\t\t\t\t\t\til blocco trait appare molto simile al \n\t\t\t\t\t\tblocco impl, \n\t\t\t\tma non contiene il corpo della funzione, solamente una firma di tipo. \n\n\t\t\t\tQuando si implementa un tratto, si usa la formula \n\t\t\t\t\timpl Trait for Item, \n\t\t\t\t\tinvece della più semplice impl Item.\n\n\n\n\n\n\n\n\n \tLegami del tratto sulle funzioni generiche\t\t\t4.19.2\n \t\n \t\tIMPORTANZA DEI TRATTI\n \t\t\tI tratti sono utili perché consentono a un tipo di fare certe PROMESSE SUL SUO COMPORTAMENTO. \n\n \t\t\tLe funzioni generiche possono sfruttare questo (I TRAIT) per vincolare, o legare, i tipi che accettano. \n\n \t\t\tSi consideri questa funzione, che non compila:\n\n \t\t\t \t//FUNZIONE GENERICA che utilizza una figura generica ma non c'è il tipo generico\n \t\t\t \tfn stampa_area<T>(figura: T) {  //rust da errore perche non c'è il tipo generico\n\t\t\t\t\t    println!(\"Questa figura ha un'area di {}\", figura.area());\n\t\t\t\t\t}\n\n\t\t\tSiccome T può essere qualunque tipo, non possiamo essere sicuri che implementi il metodo area. Ma possiamo aggiungere un tratto legato al nostro T generico, assicurando che lo faccia:\n\n\t\t\t\n\t\t\t//tratto che definisce: il TIPO GENERICO = <T: HaArea>\n\t\t\t//+ LA FIGURA GENERICA --> (figura: T)\n\t\t\tfn stampa_area<T: HaArea>(figura: T) {\n\t\t\t\t    println!(\"Questa figura ha un'area di {}\", figura.area());\n\t\t\t\t}\n\n\n\t\t\t\tLa sintassi <T: HaArea> significa \n\t\t\t\t\t“qualunque tipo che implementa il tratto HaArea.” \n\n\t\t\t\tSiccome i tratti definiscono delle firme di tipo di funzione, possiamo star sicuri che qualunque tipo che implementa HaArea avrà un metodo .area().\n\n\n\t\t\tEcco un esempio esteso di come funziona questa cosa:\n\n\n\t\t\t\t//TRATTO\n\t\t\t\ttrait HaArea {\n    \t\t\t\t\tfn area(&self) -> f64;\n\t\t\t\t\t}\n\n\n\t\t\t\t//Struttura ed implementazione del Cerchio\t\t\n\t\t\t\t//...........................................................................//\t\n\t\t\t\t\tstruct Cerchio {\n\t\t\t\t\t    x: f64,\n\t\t\t\t\t    y: f64,\n\t\t\t\t\t    raggio: f64,\n\t\t\t\t\t}\n\n\t\t\t\t\timpl HaArea for Cerchio {\n\t\t\t\t\t    fn area(&self) -> f64 {\n\t\t\t\t\t        std::f64::consts::PI * (self.raggio * self.raggio)\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t//...........................................................................//\t\n\n\n\n\t\t\t\t//Struttura ed implementazione del Quadrato\t\t\n\t\t\t\t//...........................................................................//\t\n\t\t\t\t\tstruct Quadrato {\n\t\t\t\t\t    x: f64,\n\t\t\t\t\t    y: f64,\n\t\t\t\t\t    lato: f64,\n\t\t\t\t\t}\n\n\t\t\t\t\timpl HaArea for Quadrato {\n\t\t\t\t\t    fn area(&self) -> f64 {\n\t\t\t\t\t        self.lato * self.lato\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t//...........................................................................//\t\n\t\t\t\t\n\t\t\t\t//funzione stampa che puo usare DUE TIPI DIVERSI, stringo o f64 per la stampa\n\t\t\t\t//...........................................................................//\t\n\n\t\t\t\t\t//funzione che permette di stapare tipi generici MA PER ORA CON GLI STESSI DATI\n\t\t\t\t\t//f64 altrimenti da errore\n\t\t\t\t\tfn stampa_area<T: HaArea>(figura: T) {\n\t\t\t\t\t\t    println!(\"Questa figura ha un'area di {}\", figura.area());\n\t\t\t\t\t\t}\n\t\t\t\t//...........................................................................//\n\n\n\t\t\t\tfn main() {\n\t\t\t\t    let c = Cerchio {\n\t\t\t\t        x: 0.0f64,\n\t\t\t\t        y: 0.0f64,\n\t\t\t\t        raggio: 1.0f64,\n\t\t\t\t    };\n\n\t\t\t\t    let q = Quadrato {\n\t\t\t\t        x: 0.0f64,\n\t\t\t\t        y: 0.0f64,\n\t\t\t\t        lato: 1.0f64,\n\t\t\t\t    };\n\n\n\t\t\t\tQuesto programma emette:\n\n\t\t\t\tQuesta figura ha un'area di 3.141593\n\t\t\t\tQuesta figura ha un'area di 1\n\n\n\t\t\t\tDa come si vede, stampa_area adesso è generica, ma assicura anche che le abbiamo passato i tipi corretti (solo f64). Se le passiamo un tipo scorretto:\n\n\t\t\t\t//parametro intero da errore\n\t\t\t\tstampa_area(5);\n\t\t\t\t\tOtteniamo un errore in fase di compilazione:\n\n\t\t\t\t\terror: the trait bound `_ : HasArea` is not satisfied [E0277]\n\n\n \t\n \t\tFinora, abbiamo aggiunto implementazioni di tratti solamente a delle struct, ma un tratto può essere implementato per qualunque tipo. \n\n \t\tPerciò tecnicamente, potremmo implementare HaArea anche per il tipo i32:\n\n \t\t\ttrait HaArea {\n\t\t\t\t    fn area(&self) -> f64;\n\t\t\t\t}\n\n\t\t\t\timpl HaArea for i32 {\n\t\t\t\t    fn area(&self) -> f64 {\n\t\t\t\t        println!(\"questo è sciocco\")\n\t\t\t\t        *self as f64\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t\t\t5.area();\n\n\t\t\tÈ considerato stile scadente implementare dei metodi su tali tipi primitivi, anche se è possibile.\n\n\t\t\tQuesto può sembrare come il Far West, ma ci sono due restrizioni riguardo l'implementazione dei tratti che prevengono che la cosa ci sfugga di mano. \n\t\t\t\tLa prima è che se il tratto non è definito nel nostro ambito, non si applica. \n\n\t\t\tEcco un esempio: la libreria standard fornisce un tratto Write che aggiunge delle funzionalità ai File, per fare I/O su file. Di default, un File non avrà i suoi metodi:\n\n\n\t\t\t\t\t//qui write da errore perche non è importata la libreria\n\t\t\t\t\tlet mut f = std::fs::File::open(\"foo.txt\").expect(\"Fallita apertura di foo.txt\");\n\t\t\t\t\tlet buf = b\"qualcosa\"; // stringa letterale di byte. buf: &[u8; 8\t\t\t\t\tlet risultato = f.write(buf);\n\t\t\t\t\tEcco l'errore:\n\n\t\t\t\t\terror: type `std::fs::File` does not implement any method in scope named `write`\n\t\t\t\t\tlet result = f.write(buf);\n\n\n\t\t\tDapprima dobbiamo importare il tratto Write con use:\n\n\t\t\t\t//qui funzione perche viene importata la libreria\n\t\t\t\tuse std::io::Write;\n\n\t\t\t\t\tlet mut f = std::fs::File::open(\"foo.txt\").expect(\"Fallita apertura di foo.txt\");\n\t\t\t\t\tlet buf = b\"qualcosa\"; // stringa letterale di byte. buf: &[u8; 8]\n\t\t\t\t\tlet risultato = f.write(buf);\n\t\t\t\t\tQuesto compilerà senza errori.\n\n\n\t\t\tCiò significa che anche se qualcuno fa qualcosa di male come implementare un tratto per i32, questo non ci toccherà, a meno che importiamo quel tratto.\n\n\t\t\tC'è un'altra restrizione sull'implementare i tratti: o il tratto o il tipo per cui lo stiamo implementando, devono essere definiti da noi. \n\t\t\tO per meglio dire, almeno uno di essi deve essere definito nello stesso crate in cui si trova l'impl che stiamo scrivendo. Per saperne di più sul sistema dei moduli e dei pacchetti di Rust, si veda la sezione su crate e moduli.\n\n\t\t\tPerciò, potremmo implementare il tratto HasArea per i32, dato che abbiamo definito HaArea nel nostro codice. \n\t\t\tMa se provassimo a implementare ToString, un tratto fornito da Rust, per i32, non potremmo, perché né il tratto né il tipo sono definiti nel nostro crate.\n\n\t\t\tUn'ultima cosa sui tratti: le funzioni generiche con un legame di tratto usano la ‘monomorfizzazione’ (dal greco \"mono\"=\"uno\" e \"morfo\"=\"forma\"), e quindi sono smistati staticamente. Che significa? Si guardi la sezione sugli oggetti-tratto per avere maggiori dettagli.\n\n\n\n\n\n\n\n\n\n\n\n   Regole per implementare i tratti\t\t\t\t4.19.4\n   \t\n\t \t\tFinora, abbiamo aggiunto implementazioni di tratti solamente a delle struct, ma un tratto può essere implementato per qualunque tipo. \n\n\t\t\tPerciò tecnicamente, potremmo implementare HaArea anche per il tipo i32:\n\n\t\t\t\ttrait HaArea {\n\t\t\t\t    fn area(&self) -> f64;\n\t\t\t\t}\n\n\t\t\t\timpl HaArea for i32 {\n\t\t\t\t    fn area(&self) -> f64 {\n\t\t\t\t        println!(\"questo è sciocco\")\n\t\t\t\t        *self as f64\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t\t\t5.area();\n\n\t\tÈ considerato stile scadente implementare dei metodi su tali tipi primitivi, anche se è possibile.\n\n\t\tQuesto può sembrare come il Far West, ma ci sono due restrizioni riguardo l'implementazione dei tratti che prevengono che la cosa ci sfugga di mano. \n\t\t\tLa prima è che se il tratto non è definito nel nostro ambito, non si applica. \n\n\t\tEcco un esempio: la libreria standard fornisce un tratto Write che aggiunge delle funzionalità ai File, per fare I/O su file. Di default, un File non avrà i suoi metodi:\n\n\n\t\t\t\t//qui write da errore perche non è importata la libreria\n\t\t\t\tlet mut f = std::fs::File::open(\"foo.txt\").expect(\"Fallita apertura di foo.txt\");\n\t\t\t\tlet buf = b\"qualcosa\"; // stringa letterale di byte. buf: &[u8; 8\t\t\t\t\tlet risultato = f.write(buf);\n\t\t\t\tEcco l'errore:\n\n\t\t\t\terror: type `std::fs::File` does not implement any method in scope named `write`\n\t\t\t\tlet result = f.write(buf);\n\n\n\t\tDapprima dobbiamo importare il tratto Write con use:\n\n\t\t\t//qui funzione perche viene importata la libreria\n\t\t\tuse std::io::Write;\n\n\t\t\t\tlet mut f = std::fs::File::open(\"foo.txt\").expect(\"Fallita apertura di foo.txt\");\n\t\t\t\tlet buf = b\"qualcosa\"; // stringa letterale di byte. buf: &[u8; 8]\n\t\t\t\tlet risultato = f.write(buf);\n\t\t\t\tQuesto compilerà senza errori.\n\n\n\t\tCiò significa che anche se qualcuno fa qualcosa di male come implementare un tratto per i32, questo non ci toccherà, a meno che importiamo quel tratto.\n\n\t\tC'è un'altra restrizione sull'implementare i tratti: o il tratto o il tipo per cui lo stiamo implementando, devono essere definiti da noi. \n\t\tO per meglio dire, almeno uno di essi deve essere definito nello stesso crate in cui si trova l'impl che stiamo scrivendo. Per saperne di più sul sistema dei moduli e dei pacchetti di Rust, si veda la sezione su crate e moduli.\n\n\t\tPerciò, potremmo implementare il tratto HasArea per i32, dato che abbiamo definito HaArea nel nostro codice. \n\t\tMa se provassimo a implementare ToString, un tratto fornito da Rust, per i32, non potremmo, perché né il tratto né il tipo sono definiti nel nostro crate.\n\n\t\tUn'ultima cosa sui tratti: le funzioni generiche con un legame di tratto usano la ‘monomorfizzazione’ (dal greco \"mono\"=\"uno\" e \"morfo\"=\"forma\"), e quindi sono smistati staticamente. Che significa? Si guardi la sezione sugli oggetti-tratto per avere maggiori dettagli.\n\n\n \tLegami di tratto multipli\t\t\t\t\t\t4.19.5\n \t\tAbbiamo visto che si può legare un parametro generico di tipo a un tratto:\n\n\t\t\tfn foo<T: Clone>(x: T) {\n\t\t\t    x.clone();\n\t\t\t}\n\n\n\t\tSe serve più di un legame, si può usare +:\n\n\t\t\tuse std::fmt::Debug;\n\n\t\t\t//2 tratti \n\t\t\tfn foo<T: Clone + Debug>(x: T) {\n\t\t\t    x.clone();\n\t\t\t    println!(\"{:?}\", x);\n\t\t\t}\n\t\tT adesso ha bisogno di essere sia Clone che Debug.\n\n\n\n \tLa clausola Where\t\t\t\t\t\t\t\t\t4.19.6\n \t\tScrivere funzioni con solamente alcuni tipi generici e un piccolo numero di legami di tratto non è malaccio, ma man mano che il loro numero si accresce, la sintassi divenga sempre più goffa:\n\n \t\t\tuse std::fmt::Debug;\n \t\t\t//nome funzione \t\t= foo\n \t\t\t//lisata argomenti \t= <T: Clone, K: Clone + Debug>(x: T, y: K)\n\t\t\t\tfn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n\t\t\t\t    x.clone();\n\t\t\t\t    y.clone();\n\t\t\t\t    println!(\"{:?}\", y);\n\t\t\t\t}\n\n\n\t\t\tRust ha una soluzione, e si chiama ‘clausola where’:\n\n\t\t\t\tuse std::fmt::Debug;\n\n\t\t\t\t\t\tfn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n\t\t\t\t\t\t    x.clone();\n\t\t\t\t\t\t    y.clone();\n\t\t\t\t\t\t    println!(\"{:?}\", y);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// uso la clausola where\n\t\t\t\t\t\tfn bar<T, K>(x: T, y: K) where T: Clone, K: Clone + Debug {\n\t\t\t\t\t\t    x.clone();\n\t\t\t\t\t\t    y.clone();\n\t\t\t\t\t\t    println!(\"{:?}\", y);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfn main() {\n\t\t\t\t\t\t    foo(\"Ciao\", \"mondo\");\n\t\t\t\t\t\t    bar(\"Ciao\", \"mondo\");\n\t\t\t\t\t\t}\n\t\t\tSi devono solo omettere i vincoli quando si definiscono i propri parametri di tipo, e poi aggiungere where dopo l'elenco degli argomenti. Per liste più lunghe, si possono aggiungere spaziature:\n\n\t\t\t\tuse std::fmt::Debug;\n\n\t\t\t\t\tfn bar<T, K>(x: T, y: K)\n\t\t\t\t\t    where T: Clone,\n\t\t\t\t\t          K: Clone + Debug {\n\n\t\t\t\t\t    x.clone();\n\t\t\t\t\t    y.clone();\n\t\t\t\t\t    println!(\"{:?}\", y);\n\t\t\t\t\t}\n\n\t\t\tQuesta flessibilità può aumentare la chiarezza in situazioni complesse.\n\n\t\t\twhere è anche più potente della sintassi più semplice. Per esempio:\n\n\t\t\t\ttrait ConvertiIn<Output> {\n\t\t\t\t\t    fn converti(&self) -> Output;\n\t\t\t\t\t}\n\n\t\t\t\t\timpl ConvertiIn<i64> for i32 {\n\t\t\t\t\t    fn converti(&self) -> i64 { *self as i64 }\n\t\t\t\t\t}\n\n\t\t\t\t\t// si può chiamare con T == i32\n\t\t\t\t\tfn normale<T: ConvertiIn<i64>>(x: &T) -> i64 {\n\t\t\t\t\t    x.converti()\n\t\t\t\t\t}\n\n\t\t\t\t\t// si può chiamare con T == i64\n\t\t\t\t\tfn inversa<T>(x: i32) -> T\n\t\t\t\t\t        // sta usando ConvertiIn come se fosse \"ConvertiIn<i64>\"\n\t\t\t\t\t        where i32: ConvertiIn<T> {\n\t\t\t\t\t    x.converti()\n\t\t\t\t\t}\n\n\t\t\tQuesto codice esibisce la caratteristica aggiuntiva delle clausole where: tali clausole consentono legami sul lato sinistro, non solamente dei parametri di tipo, ma anche dei tipi (in questo caso, il tipo i32). In questo esempio, i32 deve implementare ConvertiIn<T>. Invece di definire cos'è i32 (dato che è ovvio), qui la clausola where vincola T.\n\n\n\n\n\n \tI metodi di default\t\t\t\t\t\t\t\t4.19.7\n \t\t\t\n \t\t\tUn metodo di default può essere aggiunto a una definizione di tratto se è già noto come un implementatore tipico definirà un metodo. \n\n \t\t\tPer esempio, e_invalido() è definito come l'oppost di e_valido():\n\n \t\t\t\t\ttrait Foo {\n\t\t\t\t\t    fn e_valido(&self) -> bool;\n\n\t\t\t\t\t    fn e_invalido(&self) -> bool { !self.e_valido() }\n\t\t\t\t\t}\n\n\t\t\tGli implementatori del tratto Foo devono implementare e_valido(), ma possono non implementare e_invalido(), dato che ha già un comportamento di default. Questo comportamento di default può sempre essere scavalcato, come in:\n\n\t\t\t\t\t\n\t\t\t\t\tstruct UsaDefault;\n\n\t\t\t\t\t\timpl Foo for UsaDefault {\n\t\t\t\t\t\t    fn e_valido(&self) -> bool {\n\t\t\t\t\t\t        println!(\"Chiamato UsaDefault.e_valido.\");\n\t\t\t\t\t\t        true\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstruct ScavalcaDefault;\n\n\t\t\t\t\t\timpl Foo for ScavalcaDefault {\n\t\t\t\t\t\t    fn e_valido(&self) -> bool {\n\t\t\t\t\t\t        println!(\"Chiamato ScavalcaDefault.e_valido.\");\n\t\t\t\t\t\t        true\n\t\t\t\t\t\t    }\n\n\t\t\t\t\t\t    fn e_invalido(&self) -> bool {\n\t\t\t\t\t\t        println!(\"Chiamato ScavalcaDefault.e_invalido!\");\n\t\t\t\t\t\t        true // Scavalca il valore atteso di e_invalido()\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet default = UsaDefault;\n\t\t\t\t\t\tassert!(!default.e_invalido()); // stampa \"Chiamato UsaDefault.e_valido.\"\n\n\t\t\t\t\t\tlet scavalca = ScavalcaDefault;\n\t\t\t\t\t\tassert!(scavalca.e_invalido()); // stampa \"Chiamato ScavalcaDefault.e_invalido!\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n \tEreditarietà\t\t\t\t\t\t\t\t\t\t4.19.8\n\n\t\tEreditarietà\n\t\t\tTalvolta, implementare un tratto richiede implentare un altro tratto:\n\n\t\t\t\ttrait Foo {\n\t\t\t\t    fn foo(&self);\n\t\t\t\t}\n\n\t\t\t\ttrait FooBar : Foo {  //FooBar implementa anche Foo = ereditarieta\n\t\t\t\t    fn foobar(&self);\n\t\t\t\t}\n\n\n\t\tGli implementatori di FooBar devono implementare anche Foo, così:\n\n\t\t\tstruct Baz;\n\n\t\t\t\timpl Foo for Baz {\n\t\t\t\t    fn foo(&self) { println!(\"foo\"); }\n\t\t\t\t}\n\n\t\t\t\timpl FooBar for Baz {\t//FooBar implementa solo Baz e non Foo per cui da errore\n\t\t\t\t    fn foobar(&self) { println!(\"foobar\"); }\n\t\t\t\t}\n\n\n\t\t\t\tSe tralasciamo di implementare Foo, Rust ce lo dirà:\n\t\t\t\t\terror: the trait bound `main::Baz : main::Foo` is not satisfied [E0277]\n\n\n\n \tDerivazione\t\t\t\t\t\t\t\t\t\t\t4.19.9\n\n \t\tATTRIBUTO per l'implementazione automadica dei tratti = Implementare ripetutamente i tratti come Debug e Default può diventare parecchio noioso. Per tale ragione, Rust fornisce un attributo che consente di far implementare automaticamente dei tratti a Rust:\n \t\t\t\t#[derive(Debug)]\n\t\t\t\t\tstruct Foo;\n\n\t\t\t\t\tfn main() {\n\t\t\t\t\t    println!(\"{:?}\", Foo);\n\t\t\t\t\t}\n\n\t\tDERIVAZIONE LIMITATA = Però, la derivazione è limitata a un certo insieme di tratti. Eccoli:\n\t\t\t\t@derivazione@tratti_(@attributi per l'implementazione atomatica dei tratti)\n\n\t\t\t\tClone\n\t\t\t\tCopy\n\t\t\t\tDebug\n\t\t\t\tDefault\n\t\t\t\tEq\n\t\t\t\tHash\n\t\t\t\tOrd\n\t\t\t\tPartialEq\n\t\t\t\tPartialOrd\n\n DROP\t\t\t\t\t\t\t\t\t\t\t\t\t4.20.\n \tDistruzione [\"Drop\"]\t\t\t\t\t\t\t\t4.20.1\n\n \t\t\t@tratto_@Drop_(tratto di rust che svolge da distruttore utilizzato nelle struct)\n\n \t\tAdesso che abbiamo parlato dei tratti, parliamo di un particolare tratto fornito dalla libreria standard di Rust, Drop, che letteralmente significa \"lasciar cadere\", ma qui va inteso nel senso di \"distruggere\". Il tratto Drop svolge la funzione che in altri linguaggi di programmazione è svolta dai \"distruttori\"; infatti fornisce un modo di eseguire del codice quando un oggetto esce dal suo ambito.\n\n \t\t\tPer esempio:\n\n \t\t\t\tstruct DaDistruggere;\n\n\t\t\t\t\timpl Drop for DaDistruggere {\n\t\t\t\t\t    fn drop(&mut self) {\n\t\t\t\t\t        println!(\"Distruzione!\");\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\tfn main() {\n\t\t\t\t\t    let x = DaDistruggere;\n\t\t\t\t\t    \n\t\t\t\t\t    // fai qualcosa\n\n\t\t\t\t\t} // qui x esce di ambito e stampa \"Distruzione!\"\n\n\n\t\t\tQuando x esce di ambito, alla fine della funzione main(), il metodo drop verrà eseguito. Tale metodo, che è l'unico di Drop, prende un riferimento mutabile a self.\n\n\t\t\tEcco fatto! La meccanica di Drop è molto semplice, ma ci sono alcune sottigliezze. Per esempio, i valori vengono distrutti nell'ordine opposto a quello in cui sono stati dichiarati. Ecco un altro esempio:\n\n\t\t\t\tstruct Esplosivo {\n\t\t\t\t\t    energia: i32,\n\t\t\t\t\t}\n\n\t\t\t\t\timpl Drop for Esplosivo {\n\t\t\t\t\t    fn drop(&mut self) {\n\t\t\t\t\t        println!(\"BUM per {}!\", self.energia);\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\tfn main() {\n\t\t\t\t\t    let petardo = Esplosivo { energia: 1 };\n\t\t\t\t\t    let granata = Esplosivo { energia: 100 };\n\t\t\t\t\t    let bomba = Esplosivo { energia: 1000 };\n\t\t\t\t\t}\n\n\t\t\t\tQuesto programma stamperà:\n\n\t\t\t\t\tBUM per 1000!\n\t\t\t\t\tBUM per 100!\n\t\t\t\t\tBUM per 1! \t\n\n\t\t\t\tLa bomba esplode prima della granata, che esplode prima del petardo, perché sono stati dichiarati in quell'ordine invertito. Ultimo dentro, primo fuori.\n\n\t\t\t\tDunque a cosa serve il tratto Drop? In generale, Drop viene usato per distruggere le risorse associate a una struct. Per esempio, Arc<T> è un tipo che contiene un oggetto di tipo generico T e un conteggio di riferimenti. Quando viene chiamato il suo metodo drop, questo metodo decrementa il conteggio dei riferimenti, e se tale conteggio è diventato zero, dealloca l'oggetto contenuto.\n\n IF LET \t\t\t\t\t\t\t\t\t\t\t\t4.21.\n\n \tCOSTRUTTO IF LET \t\t\t\t\t\t\t\t\t4.21.1\n\t\t \tIl costrutto if let consente di combinare i costrutti if e let, per migliorare efficienza di certi tipi di pattern match.\n\t\t \tPer esempio, diciamo che abbiamo un certo Option<T>. Vogliamo chiamare una funzione su di esso, ma solo se vale Some<T>, e non fare niente se vale None. Si potrebbe fare così:\n\n\t\t \t\t//soluzione I non soddisfacente\n\t\t \t\tmatch opzione {\n\t\t\t\t\t    Some(x) => { foo(x) },\t\n\t\t\t\t\t    None => {},\n\t\t\t\t\t}\n\n\t\t\t\tQui non è necessario usare un match, perché potremmo anche usare un if:\n\n\t\t \t\t\t//soluzione II non soddisfacente\n\t\t\t\t\tif opzione.is_some() {  //se some è valido utilizzo if\n\t\t\t\t\t    foo(opzione.unwrap());\n\n\n\t\t\t    Però nessuna delle due soluzioni è particolarmente soddisfacente. Invece si può usare un if let per fare la stessa cosa in un modo più carino:\n\n\t\t \t\t\t//@if_(if che migliora l'efficienza di pattern le utilizzazione @some )\n\t\t\t    \tif let Some(x) = opzione {\n\t\t\t\t\t\t    foo(x);\n\t\t\t\t\t\t}\n\n\t\t\t\t\tSe un pattern combacia con successo, lega tutte le parti appropriate del valore agli identificatori del pattern, e poi valuta l'espressione. Se il pattern non combacia, non succede niente.\n\n\t\t\t\t\t\t\tesempio completo\n\n\n\t\t\t\t\t\t\t\t\tfn main() {\n\t\t\t\t\t\t\t\t\t    let opzione = Some(5);\n\t\t\t\t\t\t\t\t\tfn foo(x: i32) { \n\t\t\t\t\t\t\t\t\t         println!(\"\\n\n\t\t\t\t\t\t\t\t\t\t     CHIAMATA FOO ATTIVA : esempio di if let che permette di utilizzare Option T \n\t\t\t\t\t\t\t\t\t\t     solo se Some T è valido. E' combaciato il pattern let Some (x) = opzione\n\t\t\t\t\t\t\t\t\t\t     la funzione foo HA RICEVUTO X CHE VIENE STAMPATO = {}\",x);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfn bar() { }\n\t\t\t\t\t\t\t\t\tif let Some(x) = opzione {\n\t\t\t\t\t\t\t\t\t     println!(\"\\n\\n\n\t\t\t\t\t\t\t\t\t    Se combacia il pattern: let Some (x) = opzione\n\t\t\t\t\t\t\t\t\t    allora viene chiamata la funzione foo (x)  = {}\",x);\n\t\t\t\t\t\t\t\t\t    foo(x);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t    bar(); //se non combacia il pattern viene chiamata elese \n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t \t\n\twhile let\t\t\t\t\t\t\t\t\t\t\t4.21.2\n\t\tSimilmente, il costrutto while let può essere usato quando si vuole ciclare condizionalmente fin tanto che un valore combacia con un certo pattern. Trasforma il seguente codice:\n\n\t\t\t//esempio con il loop senza while let\n\t\t\tfn main() {\n\t\t\t    let mut v = vec![1, 3, 5, 7, 11];\n\t\t\tloop {\n\t\t\t\t //devo usare match\n\t\t\t    match v.pop() {\n\t\t\t        Some(x) =>  println!(\"{}\", x),\n\t\t\t        None => break,\n\t\t\t    }\n\t\t\t}\n\t\t\t}\n\n\t\t\tnel seguente codice:\n\n\t\t\t\t\tfn main() {\n\t\t\t\t\t    let mut v = vec![1, 3, 5, 7, 11];\n\n\t\t\t\t\t//qui uso while let e finche combacia il pattern Some(x) = v.pop() viene eseguito\n\t\t\t\t\twhile let Some(x) = v.pop() {\n\t\t\t\t\t    println!(\"{}\", x);\n\t\t\t\t\t}\n\t\t\t\t\t}\n\n OGGETTI-TRATTI\t\t\t\t\t\t\t\t\t\t\t4.22.\n\n \t\t@da@finire@carlomilanesi\n \t\t\thttps://carlomilanesi.github.io/linguaggio-rust/traits.html\n\n CHIUSURE\t\t\t\t\t\t\t\t\t\t\t\t4.23.\t\n SINTASSI UNIVERSALE DI CHIAMATA DI FUNZIONE\t\t\t4.24.\t\n CRATE E MODULI\t\t\t\t\t\t\t\t\t\t\t4.25.\t\n CONST E STATIC\t\t\t\t\t\t\t\t\t\t\t4.26.\t\n ATTRIBUTI\t\t\t\t\t\t\t\t\t\t\t\t4.27.\t\n ALIAS TRAMITE `TYPE`\t\t\t\t\t\t\t\t\t4.28.\t\n FORZATURA DI TIPO\t\t\t\t\t\t\t\t\t\t4.29.\t\n TIPI ASSOCIATI\t\t\t\t\t\t\t\t\t\t\t4.30.\t\n TIPI NON DIMENSIONATI\t\t\t\t\t\t\t\t\t4.31.\t\n OPERATORI E SOVRACCARICAMENTO\t\t\t\t\t\t\t4.32.\t\n COERCIZIONE DEREF\t\t\t\t\t\t\t\t\t\t4.33.\t\n LE MACRO\t\t\t\t\t\t\t\t\t\t\t\t4.34.\t\n PUNTATORI GREZZI\t\t\t\t\t\t\t\t\t\t4.35.\t\n `UNSAFE`\t\t\t\t\t\t\t\t\t\t\t\t4.36.\t\n RU\n\n ST EFFICACE\t\t\t\t\t\t\t\t\t\t\t5.0  \t\n LO STACK E LO HEAP\t\t\t\t\t\t\t\t\t\t5.1.\t\n COLLAUDO\t\t\t\t\t\t\t\t\t\t\t\t5.2.\t\n COMPILAZIONE CONDIZIONALE\t\t\t\t\t\t\t\t5.3.\t\n DOCUMENTAZIONE\t\t\t\t\t\t\t\t\t\t\t5.4.\t\n ITERATORI\t\t\t\t\t\t\t\t\t\t\t\t5.5.\t\n CONCORRENZA\t\t\t\t\t\t\t\t\t\t\t5.6.\t\n GESTIONE DEGLI ERRORI\t\t\t\t\t\t\t\t\t5.7.\t\n SCEGLIERE LE GARANZIE\t\t\t\t\t\t\t\t\t5.8.\t\n FFI\t\t\t\t\t\t\t\t\t\t\t\t\t5.9.\t\n PRESTITO E ASREF\t\t\t\t\t\t\t\t\t\t5.10.\t\n CANALI DI RILASCIO\t\t\t\t\t\t\t\t\t\t5.11.\t\n USARE RUST SENZA LA LIBRERIA STANDARD\t\t\t\t\t5.12.\t\n RUST NOTTURNO\t\t\t\t\t\t\t\t\t\t\t6.0.0\t\n PLUGIN DEL COMPILATORE\t\t\t\t\t\t\t\t\t6.1.\t\n ASSEMBLY IN-LINE\t\t\t\t\t\t\t\t\t\t6.2.\t\n OMETTERE LA LIBRERIA STDANDARD\t\t\t\t\t\t\t6.3.\t\n INTRINSECI\t\t\t\t\t\t\t\t\t\t\t\t6.4.\t\n ELEMENTI \"LANG\"\t\t\t\t\t\t\t\t\t\t6.5.\t\n LINK AVANZATO\t\t\t\t\t\t\t\t\t\t\t6.6.\t\n COLLAUDI PRESTAZIONALI\t\t\t\t\t\t\t\t\t6.7.\t\n SINTASSI DI BOX E RELATIVI PATTERN\t\t\t\t\t\t6.8.\t\n PATTERN DI SLICE\t\t\t\t\t\t\t\t\t\t6.9.\t\n COSTANTI ASSOCIATE\t\t\t\t\t\t\t\t\t\t6.10. \t\n ALLOCATORI PERSONALIZZATI\t\t\t\t\t\t\t\t6.11. \t\n GLOSSARIO\t\t\t\t\t\t\t\t\t\t\t\t7.00\t\n INDICE ANALITICO DELLA SINTASSI\t\t\t\t\t\t8.00   \t\n\n\nINDICE_COMANDI_CARGO+RUST\n\n\tC\n\t\tCONVENZIONE IN RUST\n\t\t\t\t\tVedi: https://www.freecodecamp.org/italian/news/impara-a-programmare-con-rust-corso-interattivo-in-linguaggio-rust-su-replit/#le-basi-di-rust\n\t\t\t\t\t\n\t\t\t\tNOMENCLATURA\n\t\t\t\t\tIn Rust, le convenzioni di nomenclatura sono le seguenti:\n\n\t\t\t\t\tOGGETTO\t\tSTILE\n\t\t\t\t\tVariabili\tsnake_case\n\t\t\t\t\tFunzioni\tsnake_case\n\t\t\t\t\tFile\t\tsnake_case\n\t\t\t\t\tCostanti\tSCREAMING_SNAKE_CASE\n\t\t\t\t\tStatic\t    SCREAMING_SNAKE_CASE\n\t\t\t\t\tTipi\t    PascalCase\n\t\t\t\t\tTratti\t    PascalCase\n\t\t\t\t\tEnum\t    PascalCase\n\n\t\t\t\tCONVENZIONE PER LE VARIABILI\n\t\t\t\t\til trattino basso _ indica che la variabile non è utilizzata:\n\t\t\t\t\t\tfn main() {\n\t\t\t\t\t\t\t\t  let _unused_variable = my_func(10);\n\t\t\t\t\t\t\t\t}\n\t\t\t\tPARAMETRI CON SINTASSI :\n\t\t\t\t\tI parametri di funzione vengono scritti usando la sintassi :\n\n\n\t\t\t\t\t\tfn my_func(x: u8) -> i32 {\n\t\t\t\t\t\t  x as i32\n\t\t\t\t\t\t}\n\n\t\t\t\tSTRINGHE E SLICE IN RUST\n\t\t\t\t\tUn motivo di confusione comune per i principianti di Rust è la differenza tra la struct String e il tipo str.\n\n\t\t\t\t\t\t//&str = memorizzata nello stack quindi fissa - riferimento c++ \n\t\t\t\t\t\tlet my_str: &str = \"Hello, world!\";\n\t\t\t\t\t\t//my_string = memorizzata nell'heap con grandezza sconosciuta al mento della compilazione\n\n\t\t\t\t\t\tlet my_string: String = String::from(\"Hello, world!\");\n\n\n\t\t\t\t\tNell'esempio qui sopra, my_str è un riferimento a una stringa letterale, e my_string è un'istanza della struct String.\n\n\t\t\t\t\tUn'importante distinzione tra le due è che my_str è memorizzata nello stack, mentre my_string è allocata nella memoria heap. Ciò significa che il valore di my_str non può cambiare e la sua dimensione è fissa, mentre my_string può avere una dimensione sconosciuta al tempo di compilazione.\n\n\t\t\t\t\tUna stringa letterale è anche conosciuta come string slice (letteralmente \"fetta\"), poiché &str fa riferimento a parte di una stringa. In linea generale, ecco la somiglianza tra stringhe e array:\n\n\n\tI\n\t\textern\n\t\t\tserve a comunicare a rust di utilizzare una dipendenza indicata nel .toml. CHE\n\t\t\tPROVVEDERA a scaricarla es. 0.3.0 SE NON esiste, e alla prima creazione del progetto\n\t\t\timposta anche il Cargo.lock a questa dipendenza in modo che se usciranno ulteriori versioni\n\t\t\tes. 0.3.1 instabili non saranno scaricate a meno che non si imposti manualmente nel toml.\n\t\t\tAttenzione se esce altre due versione es. 0.3.9 e la 0.4.0 POSSIAMO USARE IL COMANDO\n\t\t\t\tcargo update\n\t\t\tche permette di aggiornare la versione solo tra > 0.3.0 and <= 0.3.9 quindi tutte le successive a quella imposta ma non la quattro che dovrà essere specificata nelle dipendenze\n\t\t\tdel Cargo.toml.\n\t\t\tIl Cargo.lock fa una difesa del progetto in quanto utilizza sempre quella valida e senza errori.\n\n\t\t\t\tesempio\n\t\t\t\t\t.toml\n\t\t\t\t\t\t# Iimposto nel cargo.toml  la dipendenza della libreria rand\n\t\t\t\t\t\t[dependencies]\n\t\t\t\t\t\trand=\"0.3.0\"\n\n\t\t\t\t\t.rs\n\t\t\t\t\t\t//nel file main.rs COMUNICO a rust l'utilizzo della libreria rand con:\n\n\t\t\t\t\t\textern crate rand;\n",
			"file": "RUST_TUTORIAL_CARLO_MILANESI.MD",
			"file_size": 161950,
			"file_write_time": 133440013600939889,
			"settings":
			{
				"buffer_size": 160774,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					5,
					3,
					"right_delete",
					null,
					"AwAAAG0AAAAAAAAAbQAAAAAAAABbAAAAVklBLUJBU1NJTkktUk9TU0ktV0FMVEVSLUFSQ0lFClJPLUxVSUdJTkEtMDAwNDAtTUFSSU5PLVJNLVJBVApBLUNPTkRPTUlOSU8tTlJPOiA0LTIwMjMgMjQyLG0AAAAAAAAAbQAAAAAAAAABAAAACm0AAAAAAAAAbQAAAAAAAAABAAAACQ",
					"AQAAAAAAAAABAAAAyAAAAAAAAABtAAAAAAAAAAAAAAAAAPC/"
				],
				[
					9,
					1,
					"right_delete",
					null,
					"AQAAAG0AAAAAAAAAbQAAAAAAAAAEAAAACQkJCg",
					"AQAAAAAAAAABAAAAbQAAAAAAAABxAAAAAAAAAAAAAAAAAAAA"
				],
				[
					63,
					1,
					"left_delete",
					null,
					"AQAAAD1YAgAAAAAAPVgCAAAAAAABAAAACQ",
					"AQAAAAAAAAABAAAAPlgCAAAAAAA+WAIAAAAAAAAAAAAAAPC/"
				],
				[
					71,
					2,
					"right_delete",
					null,
					"AgAAACZYAgAAAAAAJlgCAAAAAAABAAAACiZYAgAAAAAAJlgCAAAAAAABAAAACg",
					"AQAAAAAAAAABAAAAJlgCAAAAAAAmWAIAAAAAAAAAAAAAAEBA"
				],
				[
					73,
					3,
					"right_delete",
					null,
					"AwAAAH1iAgAAAAAAfWICAAAAAAABAAAACn1iAgAAAAAAfWICAAAAAAABAAAACn1iAgAAAAAAfWICAAAAAAABAAAACg",
					"AQAAAAAAAAABAAAAfWICAAAAAAB9YgIAAAAAAAAAAAAAAAAA"
				],
				[
					75,
					1,
					"right_delete",
					null,
					"AQAAAPxiAgAAAAAA/GICAAAAAAABAAAACg",
					"AQAAAAAAAAABAAAA/GICAAAAAAD8YgIAAAAAAAAAAAAAAAAA"
				],
				[
					80,
					1,
					"left_delete",
					null,
					"AQAAAJ1iAgAAAAAAnWICAAAAAAABAAAACQ",
					"AQAAAAAAAAABAAAAnmICAAAAAACeYgIAAAAAAAAAAAAAAPC/"
				],
				[
					86,
					1,
					"left_delete",
					null,
					"AQAAAGiTAAAAAAAAaJMAAAAAAAABAAAAMA",
					"AQAAAAAAAAABAAAAaZMAAAAAAABpkwAAAAAAAAAAAAAAgH5A"
				],
				[
					89,
					1,
					"right_delete",
					null,
					"AQAAAPpiAgAAAAAA+mICAAAAAAABAAAACg",
					"AQAAAAAAAAABAAAA+mICAAAAAAD6YgIAAAAAAAAAAAAAAH5A"
				]
			]
		},
		{
			"contents": "Searching 320 files for \"@da@fare\"\n\n0 matches\n\nSearching 320 files for \"@FINIRE\"\n\n~/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_TUTORIAL_CARLO_MILANESI.MD:\n 3843   OGGETTI-TRATTI\t\t\t\t\t\t\t\t\t\t\t4.22.\t\n 3844  \n 3845:  \t\t@da@finire@carlomilanesi\n 3846   \t\t\thttps://carlomilanesi.github.io/linguaggio-rust/traits.html\n 3847  \n\n1 match in 1 file\n\n\nSearching 320 files for \"@FINIRE\"\n\n~/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_TUTORIAL_CARLO_MILANESI.MD:\n 3838   OGGETTI-TRATTI\t\t\t\t\t\t\t\t\t\t\t4.22.\n 3839  \n 3840:  \t\t@da@finire@carlomilanesi\n 3841   \t\t\thttps://carlomilanesi.github.io/linguaggio-rust/traits.html\n 3842  \n\n1 match in 1 file\n",
			"settings":
			{
				"buffer_size": 618,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			},
			"undo_stack":
			[
			]
		}
>>>>>>> 2621ea8 (agg casa)
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"Package Control: ",
				"Package Control: Install Package"
			],
			[
				"insta",
				"Package Control: Install Package"
			],
			[
				"ter",
				"Terminal: Open"
			],
			[
				"Package Control: ins",
				"Package Control: Install Package"
			],
			[
				"Package Control: RE",
				"Package Control: Remove Package"
			],
			[
				"Package Control: inst",
				"Package Control: Install Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
<<<<<<< HEAD
		"/C/CASA/LINGUAGGI/RUST_TUTORIAL",
		"/C/CASA/LINGUAGGI/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL"
=======
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL"
>>>>>>> 2621ea8 (agg casa)
	],
	"file_history":
	[
		"/C/CASA/LINGUAGGI/RUST_TUTORIAL/RUST_TUTORIAL.sublime-project",
		"/C/CASA/LINGUAGGI/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL/README.MD",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_TUTORIAL_CARLO_MILANESI.MD",
		"/media/valter/TOSHIBA EXT/CASA/LINGUAGGI/GESTIONE_LINGUAGGI/GE_LING/GE_LING_SALVATAGGI/GE_LING_N01_SALVA_TUTTO.bat",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/GIT_BAT/git_OpenGitHub.bat",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/GIT_BAT/git_STATUS+ADD+COMMIT+PUSH.BAT",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL/TUTORIAL_FREE_CODE_CAMP.MD",
		"/media/valter/TOSHIBA EXT/CASA/GE_CASA/2023_10_05_TIPO_FZ212PV_BOLLO_2023_263,95 GIA PAGA",
		"/media/valter/TOSHIBA EXT/CASA/PROGRAMMI/FIRE_FOX/bookmarks_CASA_Mozzilla.json",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL/PROGETTI_RUST/tempo_di_vita_struct/src/main.rs",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL/README.MD",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL/PROGETTI_RUST/ambito_prestito/src/main.rs",
		"/home/valter/VirtualBox VMs/Windows 10 VM 1/Window",
		"/home/valter/CASA/CARTELLACONDIVISA/PASSAGGIO_DATI/PassaggioDati.txt",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL/PROGETTI_RUST/gioco_indovina/src/main.rs",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL/PROGETTI_RUST/prestito_valori/src/main.rs",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL/PROGETTI_RUST/hello_word_cargo/Cargo.toml",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL/PROGETTI_RUST/hello_word_cargo/src/main.rs",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL/PROGETTI_RUST/hello_word_cargo/target/doc/settings.html",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL/PROGETTI_RUST/hello_word_cargo/target/doc/hello_world/fn.main.html",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/git",
		"/home/valter/.config/sublime-text/Packages/User/Package Control.user-ca-bundle",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL/PROGETTI_RUST/genera_numero_segreto/src/main.rs",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL/PROGETTI_RUST/genera_numero_segreto/numero_segreto/src/main.rs",
		"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL/RUST_PROJECT_TUTORIAL/PROGETTI_RUST/genera_numero_segreto/numero_segreto/Cargo.toml",
		"/home/valter/CASA/LINGUAGGI/SUBLIMETEXT/SUBLIMETEXT.sublime-project",
		"/home/valter/CASA/LINGUAGGI/SUBLIMETEXT/ANALISI/TUTORIAL_SUBLIMETEXT.MD",
		"/home/valter/.config/sublime-text/Packages/User/PackageResourceViewer.sublime-settings",
		"/home/valter/.config/sublime-text/Packages/User/Monokai.sublime-color-scheme",
		"/home/valter/.config/sublime-text/Packages/User/Monokai.sublime-project",
		"/home/valter/CASA/CDM/LeTorri/ZIP_RAR_INCREMENTALE.sh",
		"/home/valter/CASA/LINGUAGGI/UBUNTU/UBUNTU_TUTORIAL.md",
		"/home/valter/CASA/ADUNANZE/STUDI_ADUNANZE.tex",
		"/home/valter/.config/sublime-text/Packages/PackageResourceViewer/PackageResourceViewer.sublime-settings",
		"/home/valter/CASA/ADUNANZE/STUDI_ADUNANZE.aux",
		"/home/valter/prova.txt",
		"/home/valter/Scaricati/sublime-text_build-4152_amd64.deb",
		"/home/valter/untitled"
	],
	"find":
	{
		"height": 26.0
	},
	"find_in_files":
	{
		"height": 104.0,
		"where_history":
		[
			"",
			"*.MD",
			"",
			"*.md",
			"",
			"*.md",
			".md",
			"/home/valter/CASA/LINGUAGGI/RUST/RUST_TUTORIAL,<project filters>",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
<<<<<<< HEAD
			"@comandi@cargo",
=======
			"@FINIRE",
			"@da@fare",
			"cargo ",
			"cargo init",
			"cargo",
			"@crea",
			"@da@finire",
			"www",
			"trait",
			"@da",
			"@finire",
			"@da@finire",
			"@da@finre",
			"@da@finire",
>>>>>>> 2621ea8 (agg casa)
			"\t\t\t\t\n",
			"@trait",
			"@da@finire",
			"@salvataggio",
			"@da@finire",
			"@da@finre",
			"@codice@unico",
			"@linux",
			"@codice",
			"@salvataggio@unico",
			"@fino",
			"https",
			"@fino",
			"https:",
			"https://carlomilanesi.github.io/linguaggio-rust/getting-started.html",
			"milanesi",
			"www",
			"guardie",
			"???",
			"??=",
			"guardiani",
			"@da",
			"@finire",
			"@fino",
			"@da@finire",
			"@da",
			"todo:",
			"la@",
			"@",
			"@da",
			"@struct",
			"tempo_di",
			"foo",
			"@foo",
			"@esempio@tempo",
			"@da",
			"@da@fare",
			"@da fare",
			"@esempio@tempo_(di vita foo)",
			"@DA",
			"@esempio@di_(area scope di y)",
			"@&T",
			"@da",
			"@heap",
			"@array ",
			"@array @fisso",
			"@array",
			"@cicli@esterni",
			"@cicli @esterni",
			"@cigli @esterni",
			"@[]",
			"@puntatore",
			"@array",
			"usize",
			"@precisione",
			"@float",
			"@puntatori",
			"icivixwalter@gmail.com https://github.com/icivixwalter",
			"@->",
			"@inferenza",
			"@funzioni",
			"todo: da finire",
			"@da",
			"todo:",
			"todo :",
			"todo : da finire",
			"todo",
			"todo:",
			"_tentativo",
			"tenta_tivo",
			"tentativo",
			"foreground",
			"colore commento"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"scrollbar_highlights": true,
		"show_context": true,
		"use_buffer2": true,
		"use_gitignore": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"sheets":
			[
<<<<<<< HEAD
=======
				{
					"buffer": 0,
					"file": "RUST_TUTORIAL_CARLO_MILANESI.MD",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 160774,
						"regions":
						{
						},
						"selection":
						[
							[
								156410,
								156410
							]
						],
						"settings":
						{
							"syntax": "Packages/Markdown/Markdown.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 577.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 1,
					"selected": true,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 618,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										212,
										219
									],
									[
										498,
										505
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								553,
								559
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 3,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"stack_multiselect": false,
					"type": "text"
				}
>>>>>>> 2621ea8 (agg casa)
			]
		}
	],
	"incremental_find":
	{
		"height": 26.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "RUST_TUTORIAL.sublime-project",
	"replace":
	{
		"height": 48.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"~/CASA/LINGUAGGI/UBUNTU/UBUNTU_PROJECT.sublime-project"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": false,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 312.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
