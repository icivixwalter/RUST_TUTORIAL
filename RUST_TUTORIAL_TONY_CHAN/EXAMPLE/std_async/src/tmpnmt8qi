/* PROGETTO DI GESTIONE DELLA SINCRONIZZAZIONE DEI THREAD
- std::sync: offre strumenti per la sincronizzazione tra thread, come Mutex e Arc.
Questi consentono di condividere dati tra thread in modo sicuro, prevenendo race
conditions e altri problemi comuni nella programmazione concorrente


   @std@async_(esempio di programmazione concorrente con Mutex ed Arc)


*/


use std::thread;
use std::time::Duration;

/*
Utilizziamo  Mutex  per  garantire  l'accesso  sicuro  a  un  contatore  condiviso  tra  pi√π
thread. Mentre con Arc gestiamo il contatore in maniera sicura e condivisa.

spiegazioni:

@spawn.01?
==============================================================================================================
    Cos‚Äô√® thread::spawn?
    spawn √® una funzione del modulo std::thread che crea un nuovo thread
    e lo avvia immediatamente.
    Sintassi generale:
            let handle = std::thread::spawn(|| {
                // codice eseguito nel nuovo thread
            });

    La funzione prende una closure (una funzione anonima) che
        contiene il codice da eseguire nel nuovo thread.

    Restituisce un handle (JoinHandle), che permette
        al thread che l‚Äôha creato di aspettare la fine
        del thread secondario (con .join()).

    Perch√© si chiama spawn?


@unwrap().03?  Il termine spawn in informatica significa "generare", "creare", "generare un nuovo processo o thread".
            In Rust (e in molti altri linguaggi e sistemi), spawn indica la creazione e
    Perch√© si chiama spawn?

    Perch√© si chiama spawn?
            avvio di un thread in modo asincrono
            (cio√® il nuovo thread lavora in parallelo a quello principale).

            Non √® solo creare un thread, ma anche avviarlo subito,
            quindi "farlo nascere" ed eseguire la closure passata.

    Cosa succede se non uso spawn?
            Se non usassi spawn, tutto il codice sarebbe eseguito nel thread principale in sequenza.
            spawn serve proprio a creare concorrenza: pi√π thread che lavorano contemporaneamente.

    In sintesi:
        thread::spawn crea e avvia un thread separato.
        Il codice dentro la closure √® eseguito contemporaneamente al thread principale.
        Ti permette di fare operazioni parallele e concorrenti.

==============================================================================================================

@sleep.02?
==============================================================================================================
    Spiegazione dettagliata
            thread::sleep(...) ‚Üí sospende l'esecuzione del thread attivo per un certo tempo.
            Duration::from_millis(50) ‚Üí crea una durata temporale di 50 millisecondi.

==============================================================================================================


@unwrap().03?

==============================================================================================================
S√¨, esattamente! ‚úÖ In Rust, .unwrap() pu√≤ essere utilizzato sia con
    Result<T, E> che con Option<T>,
e funziona in modo simile in entrambi i casi:

.1. .unwrap() su Result<T, E>
    Chiama .unwrap() quando sei sicuro che il risultato √® Ok(T), e vuoi ottenere il valore direttamente.
         Ma se il valore √® Err(E), .unwrap():
        fa panic (cio√® il programma si blocca)
        e stampa il messaggio dell‚Äôerrore contenuto in Err
    esempio:
                use std::fs::File;
                fn main() {
                    // Prova ad aprire un file
                    let file_result = File::open("dati.txt");

                    // Usa unwrap per ottenere il file se esiste
                    let file = file_result.unwrap();  // <-- qui si ottiene il file, o panic se non trovato
                    println!("File aperto correttamente: {:?}", file);
                    }

            ‚ñ∂Ô∏è Possibili casi:
                File dati.txt esiste?   file_result √®...    .unwrap() fa...
                ‚úÖ S√¨    Ok(File)    Ritorna il File
                ‚ùå No    Err(e)  Fa panic + stampa messaggio dell'errore


            ‚úÖ Come evitare il panic?
                Meglio usare .expect("spiegazione") oppure match:
                    .expect(): messaggio di errore personalizzato
                        let file = File::open("dati.txt").expect("Impossibile aprire il file dati.txt");

                oppure utilizzare il match: controllo esplicito
                    let file_result = File::open("dati.txt");

                        match file_result {
                            Ok(file) => println!("Aperto: {:?}", file),
                            Err(e) => println!("Errore: {}", e),
                        }


            | Tipo     | Casi possibili | Scopo                        | `.unwrap()` panica se... |
            | -------- | -------------- | ---------------------------- | ------------------------ |
            | `Option` | `Some`, `None` | Presenza o assenza di valore | √à `None`                 |
            | `Result` | `Ok`, `Err`    | Successo o fallimento        | √à `Err(E)`               |

            üí° Riassunto
                    Result = usato per gestire errori (es. I/O, parsing, rete...)
                    .unwrap() ottiene il valore di Ok, ma panica se Err
                    Preferibile usare expect o match per gestire elegantemente i casi di errore



 2. .unwrap() su Option<T>
  üîπ 1. .unwrap() su Option<T>
    Comportamento:

        Se √® Some(val), .unwrap() restituisce val.
        Se √® None, il programma va in panic.

        esempio:



Utilizziamo
    Mutex  per  garantire  l'accesso  sicuro  a  un  contatore  condiviso  tra  pi√π
    thread. Mentre con Arc gestiamo il contatore in maniera sicura e condivisa.
==============================================================================================================

*/
fn main() {
    // ===========================
    // PRIMA PARTE - ESECUZIONE CON THREAD
    // ===========================

     println!("PROGETTO DI GESTIONE DELLA LIBRERIA STD::Async!");

    // Creazione di un nuovo thread con thread::spawn
    println!("Creo il thread principale ");
    //@spawn.01?
    let handle = thread::spawn(|| {
        // Questo thread esegue un ciclo e stampa un messaggio
        for i in 1..5 {
            println!("Ciao dal thread secondario! {}", i);
            //@sleep.02?
            thread::sleep(Duration::from_millis(50));
        }
    });

    // Nel frattempo, il thread principale fa qualcos'altro
    for i in 1..5 {
        println!("Ciao dal thread principale STA LAVORANDO! {}", i);
        thread::sleep(Duration::from_millis(50));
    }

    // Attende che il thread secondario termini
    //  @unwrap().03? =  √® un metodo che si usa per ottenere il valore contenuto in un tipo Result<T, E> o Option<T>.
    handle.join().unwrap();

    // ===========================
    // SECONDA PARTE - CONDIVISIONE DATI CON Arc + Mutex
    // ===========================

    use std::sync::{Arc, Mutex};

    // Arc consente di condividere dati tra pi√π thread in sicurezza
    // Mutex assicura che solo un thread per volta possa accedere/modificare il dato
    let contatore = Arc::new(Mutex::new(0));

    // Vettore per conservare tutti gli handle dei thread
    let mut handles = vec![];

    for _ in 0..10 {
        // Cloniamo l'Arc per passare una copia al thread
        let contatore = Arc::clone(&contatore);

        // Ogni thread incrementa il valore all'interno del Mutex
        let handle = thread::spawn(move || {
            // Acquisisce il lock sul Mutex
            let mut num = contatore.lock().unwrap();
            *num += 1; // Incrementa il contatore
            // Il lock viene rilasciato automaticamente alla fine dello scope
        });

        // Salviamo l'handle per poter fare join pi√π tardi
        handles.push(handle);
    }

    // Aspettiamo che tutti i thread finiscano
    for handle in handles {
        handle.join().unwrap();
    }

    // Stampiamo il risultato finale
    println!("Risultato: {}", *contatore.lock().unwrap());
}
